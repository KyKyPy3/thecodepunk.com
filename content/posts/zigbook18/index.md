---
title: Тестирование
date: 2025-04-18 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - unittest
  - testing
---

Когда вы пишете программу на низкоуровневом языке, таком как Zig, тестирование становится важной и неотъемлемой частью процесса разработки. В высокоуровневых языках часть ошибок может быть устранена за счёт более «умного» рантайма, использования сложных абстракций или встроенного контроля времени жизни переменных. В Zig же вам приходится самостоятельно проверять и контролировать поведение программы во всех аспектах.

Разумеется, язык предоставляет ряд инструментов, позволяющих выявлять ошибки как на этапе компиляции, так и во время выполнения. Однако наиболее надёжным способом обеспечения корректности остаётся написание тестов.

Допустим, у нас есть функция, которая должна возвращать сумму двух чисел. В её сигнатуре указано, что она принимает два целых числа и возвращает целое число. В таком случае компилятор может проверить, что мы передали параметры нужного типа и корректно обработали возвращаемое значение.

Однако компилятор не способен гарантировать, что функция действительно выполняет именно ту логику, которую мы задумали. Единственный способ это проверить — написать тесты, которые убедятся в правильности работы функции на различных входных данных. Мы можем написать тесты, которые например проверяют, что при передаче в функцию чисел 1 и 2 она вернёт 3. И мы можем выполнять наши тесты каждый раз, когда вносим изменения в код, чтобы убедится, что поведение нашей функции не изменилось и по прежнему правильное.

Тем не менее, многие программисты не любят писать тесты. Кто-то избегает этого, потому что написание тестов требует времени и усилий, и возникает мысль: зачем тратить ресурсы, если функция и так «работает правильно»? Кто-то не любит писать тесты потому, что язык программирования или инфраструктура проекта предоставляет неудобный или слишком сложный интерфейс для их написания и запуска — особенно когда после обновления инструментов приходится разбираться заново и чинить сломанные тесты.

Однако мой опыт разработки достаточно крупных проектов показывает: наличие тестов почти всегда оправдывает затраченные усилия — и не один раз. Каждый раз, внося изменения в код, вы можете быть уверены, что ваша функция продолжает работать корректно.

## Создание тестов
Чтобы добавить тесты в ваш код на языке Zig, достаточно объявить специальный тестовый блок (test) в нужном месте и поместить в него код, проверяющий необходимую функциональность. Это делается очень просто и не требует дополнительной настройки или подключения внешних инструментов.

Тестовые блоки можно размещать как непосредственно рядом с тестируемым кодом, так и в конце файла модуля — выбор зависит от ваших предпочтений и стиля проекта. Это скорее вопрос вкуса и привычки. Тем не менее, если вы заглянете в исходный код стандартной библиотеки Zig, то заметите, что там принят подход, при котором тесты обычно располагаются прямо рядом с тем кодом, который они проверяют. Это делает тесты более удобными для поддержки и улучшает читаемость, особенно в небольших модулях.

В самом базовом случае тест представляет собой обычную функцию, внутри тестового блока. Однако для того, чтобы эта функция действительно выполняла проверку корректности работы кода, в ней нужно явно указать условия, которые должны быть выполнены. Это делается с помощью функций из встроенного модуля `std.testing`.

Например, давайте напишем простой тест для нашей функции `add`, которая складывает два числа. Сначала определим саму функцию, а затем проверим её работу с помощью теста:

```zig
const std = @import("std");
const expect = std.testing.expect;

pub fn sum(a: i32, b: i32) i32 {
    return a + b;
}

test "testing simple sum" {
    const a: i32 = 1;
    const b: i32 = 2;
    try expect(sum(a, b) == 3);
}
```

Теперь давайте разберёмся, как запустить наши тесты. Для этого достаточно выполнить команду zig test в терминале, указав путь к файлу, содержащему тесты. Например, если файл с тестами находится в директории src, можно использовать следующую команду:

```
$ zig test src/root.zig
```

В этом случае компилятор скомпилирует тестовый код и запустит его с помощью встроенного тестового раннера из стандартной библиотеки Zig.

Важно отметить, что при обычной сборке приложения (через zig build или компиляцию исполняемого файла) все тестовые блоки будут проигнорированы — они не попадут в финальный бинарник и не повлияют на производительность или размер итоговой программы.

Итак, если мы теперь запустим наш тест с помощью команды zig test, то увидим примерно следующий вывод:

```
$ zig test src/root.zig
All 1 tests passed.
```

Как мы видим, наш тест успешно прошёл, и компилятор вывел статистику: был запущен один тест, и он завершился без ошибок. Это подтверждает, что функция add работает корректно для заданных входных данных.

При определении тестового блока в Zig мы можем указать для него имя — это особенно полезно при большом количестве тестов, так как позволяет легко идентифицировать каждый из них в выводе компилятора. Именованные тесты делают результаты выполнения более наглядными и упрощают отладку в случае ошибок.

Давайте теперь добавим ещё один тест, но специально допустим в нём ошибку, чтобы он не прошёл. Посмотрим, как в этом случае изменится вывод компилятора и что именно он покажет нам при падении теста. Это поможет понять, как Zig сообщает об ошибках в тестах и насколько удобно их анализировать.

```zig
const std = @import("std");
const expect = std.testing.expect;

pub fn sum(a: i32, b: i32) i32 {
    return a + b;
}

test "testing simple sum" {
    const a: i32 = 1;
    const b: i32 = 2;
    try expect(sum(a, b) == 3);
}

test "testing failed sum" {
    return error.Failed;
}
```

Если мы запустим тесты теперь, то увидим следующий вывод:

```
$ zig test src/root.zig
2/2 root.test.testing failed sum...FAIL (Failed)
/Users/roman/Projects/zig/simple/src/root.zig:15:5: 0x10225dc73 in test.testing failed sum (test)
    return error.Failed;
    ^
1 passed; 0 skipped; 1 failed.
```

Как мы видим, один из наших тестов завершился с ошибкой. Об этом сообщает компилятор, указав имя тестового блока, а также точную строку, на которой произошёл сбой. Это помогает быстро локализовать проблему и приступить к её устранению.

Ещё один важный момент, который стоит отметить: если из тестового блока возвращается ошибка, тест считается неуспешным. То есть, любое возвращаемое значение типа `error` интерпретируется как провал теста. Это значит, что для написания простых тестов вам не обязательно использовать функции из модуля `std.testing`. Вы можете просто вернуть ошибку напрямую из теста, чтобы указать на некорректное поведение.

Тем не менее, использование функций из модуля testing — таких как expect, expectEqual, expectError и других — делает тесты не только более выразительными, но и улучшает читаемость вывода в случае ошибок. Такие функции предоставляют более подробную информацию о том, что именно пошло не так, и значительно упрощают анализ и отладку тестов, особенно в больших проектах.

Вы можете комбинировать несколько проверок в одном тестовом блоке, либо наоборот выносить каждую проверку в отдельный тестовый блок с уникальным именем. В этом плане Zig предоставляет вам простой и очень гибкий инструмент для написания тестов, где каждый выбирает тот стиль создания тестов, который ему кажется наиболее удобным. Обычно правда можно встретить микс из комбинированных проверок и отдельных тестов.

## Документирующие тесты
Если при создании тестового блока вместо текстового описания указать имя функции или переменной, то такой тест будет считаться документирующим тестом и будет включён в документацию по модулю.

Хорошей практикой считается добавлять документирующие тесты в тех случаях, когда они помогают пользователю вашей библиотеки понять, как использовать функции или переменные. Однако не стоит включать такие тесты, если они не несут полезной информации или касаются только внутренних деталей реализации.

Давайте рассмотрим пример документирующего теста:

```zig
//! This module provides arithmetic functions.

const std = @import("std");
const expect = std.testing.expect;

/// Sum two integers.
pub fn sum(a: i32, b: i32) i32 {
    return a + b;
}

test sum {
    const a: i32 = 1;
    const b: i32 = 2;
    try expect(sum(a, b) == 3);
}
```

Если мы теперь сгенерируем документацию к нашему проекту, выполнив команду `zig build-lib -femit-docs src/root.zig`, то при просмотре документации по нашей функции `sum` мы увидим блок `Example Usage`. где будет приведен наш тест:

```
Function
pub fn sum(a: i32, b: i32) i32
Sum two integers.

Parameters
a: i32
b: i32

Example Usage
test sum {
    const a: i32 = 1;
    const b: i32 = 2;
    try expect(sum(a, b) == 3);
}

Source Code
pub fn sum(a: i32, b: i32) i32 {
    return a + b;
}
```

В нашем примере тест, конечно, не особо полезен — мы добавили его лишь для демонстрации. В реальных проектах стоит добавлять такие тесты только в том случае, если они действительно принесут пользу тем, кто будет использовать вашу библиотеку.

## Встроенные тестовые функции

## Собственные тестовые функции

## Фильтрация тестов

## Кастомный тест раннер

## Заключение
