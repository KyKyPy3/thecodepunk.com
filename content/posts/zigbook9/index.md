---
title: Функции и работа с ошибками
date: 2025-03-08 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - function
  - errors
---

Функции — это один из основных строительных блоков в программировании. Они позволяют организовывать код в повторно используемые и модульные блоки, что делает программы более структурированными и удобными для поддержки. Zig не является исключением: в этом языке функции играют ключевую роль, предоставляя разработчикам мощные и гибкие инструменты для работы с кодом.

В этой главе мы рассмотрим, как объявлять и использовать функции в Zig, а также изучим их особенности. Во второй части главы мы затронем тему работы с ошибками. В Zig функции могут возвращать не только результат вычислений, но и ошибки, если что-то идет не так. Механизм обработки ошибок в Zig имеет сходства с подходом, используемым в языке Rust, но при этом обладает своими уникальными особенностями.

## Объявление функций
В Zig функция объявляется с использованием ключевого слова `fn`. Базовая структура функции выглядит следующим образом:

```zig
fn имя_функции(параметры) возвращаемый_тип {
    // Тело функции
}
```

Например, простая функция, которая складывает два числа выглядит так:

```zig
fn add(a: i32, b: i32) i32 {
    return a + b;
}
```

Здесь:
* add — имя функции.
* a: i32 и b: i32 — параметры функции, оба имеют тип i32 (32-битное целое число со знаком).
* i32 после списка параметров — это возвращаемый тип функции.
* return a + b; — возвращает сумму a и b.

Как мы уже рассматривали в главе 2 в Zig есть тип `void`, который используется для функций, не возвращающих значения. Например, функция, которая просто печатает сообщение на экран, может быть объявлена следующим образом:

```zig
fn print_message(message: []const u8) void {
    std.debug.print("{}", .{message});
}
```

Здесь:
* print_message — имя функции.
* message: []const u8 — параметр функции, который представляет собой строку, передаваемую в функцию.
* void после списка параметров — это возвращаемый тип функции, который указывает, что функция не возвращает никакого значения.

Второй тип данных, который мы рассматривали в главе 2 был тип `noreturn`. Этот тип используется тогда, когда надо указать что функция никогда не вернет управление, например, когда функция вызывает `std.process.exit` или `@panic`.

```zig
fn exit_with_message(message: []const u8) noreturn {
    print_message(message);
    std.process.exit(1);
}
```

В данном примере после вызова функции `print_message`, функция `exit_with_message` завершает выполнение программы с кодом ошибки 1, используя `std.process.exit(1)`. Это гарантирует, что программа завершится после вывода сообщения об ошибке.

По умолчанию все функции, которые вы определяете в своем модуле не доступны из других модулей. Для того чтобы функцию сделать доступной из других модулей, вы можете использовать ключевое слово `pub` перед объявлением функции. Предположим что у нас есть файл `math.zig`, где мы собрали функции для работы с математическими операциями. Если наша функция в данном модуле будет обьявлена без ключевого слова `pub`, то она будет недоступна из других модулей, а ее можно будет использовать только в файле `math.zig`. Если попытатся вызвать ее из другого модуля компилятор выдаст ошибку. Вот пример:

```zig
// Файл: math.zig

fn add(a: i32, b: i32) i32 {
    return a + b;
}
```

Чтобы исправить наш код, давайте добавим ключевое слово `pub` перед объявлением функции `add`:

```zig
// Файл: math.zig

pub fn add(a: i32, b: i32) i32 {
    return a + b;
}

// Файл: main.zig

const math = @import("math.zig");

pub fn main() void {
    const result = math.add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Ключевое слово `pub` в Zig — это простой, но мощный инструмент для управления видимостью функций и других элементов. Оно помогает создавать модульные и безопасные программы, четко разделяя публичный API и внутреннюю реализацию. Используйте pub для экспорта функций, которые должны быть доступны извне, и оставляйте остальные функции приватными для улучшения инкапсуляции и читаемости кода.

### Экспорт и импорт функций для использования в других языках программирования
В Zig ключевые слова `extern` и `export` используются для взаимодействия с внешним миром — другими языками программирования или системами. Они позволяют указывать, как функции должны быть видимы за пределами текущего модуля или даже за пределами программы (например, при взаимодействии с C или другими языками). Давайте разберем их подробнее.

Иногда бывает полезно сделать доступной вашу функцию не только для других модулей кода на Zig, но и для других языков программирования, используя FFI (Foreign Function Interface). Для этого вы можете использовать ключевое слово `export`. Это полезно, если вы создаете библиотеку на Zig, которую хотите использовать в других проектах. Например чтобы сделать доступной функцию `add`, вы можете использовать следующий код:

```zig
// Экспортируем функцию для использования в C
export fn add(a: c_int, b: c_int) c_int {
    return a + b;
}
```
Важный момент: типы переменных используемых в функции должны быть совместимы с тем языком, в который вы хотите экспортировать вашу функцию. В данном примере мы используем типы совместимые с языком C, но об этом мы поговорим позднее когда будем обсуждать интеграцию Zig и C.

Ключевое слово extern используется для объявления функций, которые определены вне Zig (например, в C или других языках). Это позволяет Zig вызывать функции из внешних библиотек или системных API.

Предположим, у нас есть C-библиотека с функцией add, которая складывает два числа:

```c
// Файл: math.c
int add(int a, int b) {
    return a + b;
}
```

Чтобы вызвать эту функцию из Zig, нужно объявить её с ключевым словом extern:

```zig
// Файл: main.zig

// Объявляем внешнюю функцию
extern fn add(a: c_int, b: c_int) c_int;

pub fn main() void {
    const result = add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Здесь мы используем ключевое слово extern для объявления функции add, которая определена в C-библиотеке. Это позволяет Zig вызывать эту функцию из своего кода. Важно чтобы типы данных в `extern` функциях были совместимы с внешним языком (например, c_int, c_void и т.д.). Вторым важным моментом является то, что имя функции и её сигнатура (типы аргументов и возвращаемого значения) должны точно совпадать с тем, как она объявлена во внешней библиотеке

### Встраиваемые функции
В Zig ключевое слово inline используется для подсказки компилятору, что функцию следует "встроить" (inline) в месте её вызова. Это означает, что вместо вызова функции как отдельной сущности, её код будет вставлен непосредственно в то место, где она вызывается. Это может привести к оптимизации производительности, особенно для небольших функций, которые вызываются часто.

Для того чтобы обьявить вашу функцию как встраеиваемую, используйте ключевое слово inline перед объявлением функции. Это подсказка компилятору, что функцию следует встроить. Однако стоит помнить, что inline — это именно подсказка, а не строгое указание. Компилятор может проигнорировать её, если сочтёт, что встраивание неэффективно. Давайте посмотрим на примере:

```zig
inline fn add(a: i32, b: i32) i32 {
    return a + b;
}

pub fn main() void {
    const result = add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Для чего может быть полезно использовать встраивание функций:
* **Уменьшение накладных расходов**: Встраивание устраняет необходимость в вызове функции, что может быть полезно для небольших функций, вызываемых часто.
* **Оптимизация производительности**: Встроенные функции могут быть оптимизированы компилятором более эффективно, особенно если они работают с константами или небольшими данными.
* **Упрощение отладки**: Встроенные функции могут сделать код более линейным, что упрощает его анализ и отладку.

Однако надо быть осторожным со встраиванием функций, так как это может привести к увеличению размера исполняемого файла.

## Передача параметров функции
