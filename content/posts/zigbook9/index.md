---
title: Структуры
date: 2025-03-08 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - struct
---

Для завершения базового блока ознакомления с языком Zig нам осталось рассмотреть еще одну очень важную тему - структуры. Так как язык Zig ближе к языку C, чем к таким языкам как C++ и Java, в нем нет привычного для этих языков подхода к ООП в виде классов, наследования и интерфейсов. В языке Zig для реализации некоторых принципов ООП используются структуры.

Структуры (struct) — это одна из ключевых конструкций в Zig, позволяющая группировать данные и создавать пользовательские типы. Они используются для организации сложных данных, представления объектов и моделирования реальных сущностей. В этой главе мы подробно рассмотрим, как работать со структурами в Zig, их синтаксис, особенности и примеры использования.

## Определение структур
Для того чтобы определить структуру в языке Zig используется ключевое слово `struct`, после которого идет имя вашей структуры и фигурные скобки, в которых определяются поля структуры. Рассмотрим простой пример структуры, представляющей точку в двумерном пространстве:

```zig
const Point = struct {
    x: i32,
    y: i32,
};
```

Обычно название структуры принято называть с большой буквы, тем самым мы указываем, что это имя типа данных. Имя структуры должно по возможности выразительно описывать ее назначение и содержимое. Например, если структура представляет собой данные о пользователе, ее имя может быть `User`, а если она содержит информацию о товаре, то `Product`. Это поможет другим разработчикам понять, что именно хранит данная структура и как ее использовать.

В блоке структуры, внутри фигурных скобок, мы определяем имена и типы элементов данных, которые называются «поля». Определение структуры всегда должно заканчиваться точкой с запятой, так же как это происходит в языке C.

## Создание экземпляров структур

Для того чтобы создать экземпляр структуры, мы используем ее имя и передаем значения для каждого поля в фигурных скобках. Например, чтобы создать экземпляр структуры `Point` с координатами (10, 20), мы пишем:

```zig
const std = @import("std");
const Point = struct {
    x: i32,
    y: i32,
};

pub fn main() void {
    var p = Point{ .x = 10, .y = 20 };
    std.debug.print("Point: ({d}, {d})\n", .{ p.x, p.y });
}
```

Обратите внимание на синтаксис инициализации полей: перед именем поля ставится точка (`.x = 10`). Это специальный синтаксис Zig, который делает код более читаемым и явно указывает, какие поля мы инициализируем.

Этот код создает экземпляр структуры `Point` с координатами (10, 20) и выводит его на экран:

```
Point: (10, 20)
```

## Конструкторы и деструкторы

Часто для создания экземпляров структур используется конструктор, который позволяет инициализировать поля структуры в более удобном и читаемом виде. В Zig нет встроенного механизма конструкторов, как в объектно-ориентированных языках, но мы можем определить функцию внутри структуры, которая будет выполнять роль конструктора.

Например, для структуры `Point` можно создать конструктор:

```zig
const std = @import("std");
const Point = struct {
    x: i32,
    y: i32,

    pub fn init(x: i32, y: i32) Point {
        return Point{ .x = x, .y = y };
    }
};

pub fn main() void {
    var p = Point.init(10, 20);
    std.debug.print("Point: ({d}, {d})\n", .{ p.x, p.y });
}
```

В данной реализации мы создаем экземпляр структуры `Point` с помощью функции `init`, которая принимает координаты `x` и `y` и возвращает экземпляр структуры `Point` с этими координатами.

Обычно для простых структур конструкторы не нужны, так как можно использовать инициализацию в фигурных скобках. Но они становятся полезными в следующих случаях:

1. Когда у структуры много полей, и мы хотим предоставить значения по умолчанию
2. Когда требуется валидация входных данных
3. Когда необходимо выполнить сложную логику при инициализации
4. Когда внутри структуры используется динамическое выделение памяти

Если ваша структура содержит поля, требующие освобождения ресурсов (например, динамически выделенную память), вам также понадобится функция деструктора. В Zig, по соглашению, для этой цели используется функция с именем `deinit`:

```zig
const std = @import("std");
const Allocator = std.mem.Allocator;

const DynamicArray = struct {
    data: []i32,
    allocator: *Allocator,

    pub fn init(allocator: *Allocator, size: usize) !DynamicArray {
        const data = try allocator.alloc(i32, size);
        return DynamicArray{
            .data = data,
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *DynamicArray) void {
        self.allocator.free(self.data);
    }
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = &gpa.allocator;

    var array = try DynamicArray.init(allocator, 10);
    defer array.deinit();

    // Работа с массивом...
    for (0..array.data.len) |i| {
        array.data[i] = @intCast(i32, i) * 2;
    }

    std.debug.print("Array: ", .{});
    for (array.data) |value| {
        std.debug.print("{d} ", .{value});
    }
    std.debug.print("\n", .{});
}
```

В этом примере мы создаем структуру `DynamicArray`, которая содержит динамически выделенный массив и ссылку на аллокатор. Конструктор `init` выделяет память для массива, а деструктор `deinit` освобождает эту память. Обратите внимание на использование ключевого слова `defer` для гарантированного вызова деструктора, даже в случае возникновения ошибок.

По соглашению в языке Zig для имен конструкторов и деструкторов структур используются имена `init` и `deinit` соответственно. Вы, конечно, можете использовать удобное вам имя для конструктора, но для деструктора настоятельно рекомендуется использовать имя `deinit`, чтобы соответствовать стандартной библиотеке и ожиданиям других разработчиков.

Вы также вправе создавать несколько конструкторов для одной структуры, если это необходимо. Например, вы можете создать конструктор, который принимает начальный размер массива и конструктор, который принимает начальный размер и начальное значение элементов массива.

## Методы структур

Структуры в Zig могут содержать не только поля данных, но и функции, которые работают с этими данными. Такие функции часто называют методами структуры. Рассмотрим пример структуры `Rectangle` с методами для вычисления площади и периметра:

```zig
const std = @import("std");

const Rectangle = struct {
    width: f32,
    height: f32,

    pub fn init(width: f32, height: f32) Rectangle {
        return Rectangle{ .width = width, .height = height };
    }

    pub fn area(self: Rectangle) f32 {
        return self.width * self.height;
    }

    pub fn perimeter(self: Rectangle) f32 {
        return 2 * (self.width + self.height);
    }

    pub fn scale(self: *Rectangle, factor: f32) void {
        self.width *= factor;
        self.height *= factor;
    }
};

pub fn main() void {
    var rect = Rectangle.init(5.0, 3.0);

    std.debug.print("Rectangle: width={d}, height={d}\n", .{ rect.width, rect.height });
    std.debug.print("Area: {d}\n", .{rect.area()});
    std.debug.print("Perimeter: {d}\n", .{rect.perimeter()});

    rect.scale(2.0);
    std.debug.print("After scaling: width={d}, height={d}\n", .{ rect.width, rect.height });
    std.debug.print("New area: {d}\n", .{rect.area()});
}
```

В этом примере мы определили три метода для структуры `Rectangle`:
1. `area()` - вычисляет площадь прямоугольника
2. `perimeter()` - вычисляет периметр прямоугольника
3. `scale()` - изменяет размеры прямоугольника, умножая их на указанный коэффициент

Обратите внимание, что методы `area()` и `perimeter()` принимают параметр `self` по значению, так как они только читают данные структуры. А метод `scale()` принимает `self` по указателю (`*Rectangle`), так как он изменяет поля структуры.
