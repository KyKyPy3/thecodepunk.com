---
title: Функции, перечисления и работа с ошибками
date: 2025-03-07 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - function
  - errors
---

В этой главе мы рассмотрим, как объявлять и использовать функции в Zig, а также изучим их особенности. Во второй части главы мы затронем тему работы с перечислениями и в частности их использование для обратотки ошибок. В Zig функции могут возвращать не только результат вычислений, но и ошибки, если что-то идет не так. Механизм обработки ошибок в Zig имеет сходства с подходом, используемым в языке Rust, но при этом обладает своими уникальными особенностями.

## Функции
Функции — это один из основных строительных блоков в программировании. Они позволяют организовывать код в повторно используемые и модульные блоки, что делает программы более структурированными и удобными для поддержки. Zig не является исключением: в этом языке функции играют ключевую роль, предоставляя разработчикам мощные и гибкие инструменты для работы с кодом.

### Объявление функций
В Zig функция объявляется с использованием ключевого слова `fn`. Базовая структура функции выглядит следующим образом:

```zig
fn имя_функции(параметры) возвращаемый_тип {
    // Тело функции
}
```

Например, простая функция, которая складывает два числа выглядит так:

```zig
fn add(a: i32, b: i32) i32 {
    return a + b;
}
```

Здесь:
* add — имя функции.
* a: i32 и b: i32 — параметры функции, оба имеют тип i32 (32-битное целое число со знаком).
* i32 после списка параметров — это возвращаемый тип функции.
* return a + b; — возвращает сумму a и b.

Для того чтобы вызвать функцию, мы используем ее имя и передаем ей аргументы в круглых скобках. Например, чтобы сложить два числа 3 и 5, мы вызываем функцию `add` следующим образом:

```zig
const result = add(3, 5);
```

При вызове функции, как мы уже знаем из главы про стек, компилятор создаст для нас стековый фрейм, где разместит все локальные переменные функции и переданные ей аргументы. Аргументы функции будут размещены на стеке в порядке справа налево. Для небольших функций компилятор может применить оптимизацию и передать параметры функции через регистры процессора.

### Передача параметров функции
Функции в Zig, как и в других языках программирования, могут принимать параметры, которые передаются в них при вызове. Однако в Zig есть несколько особенностей, связанных с передачей параметров, которые делают этот язык гибким и мощным.

По умолчанию в Zig параметры передаются по значению. Это означает, что функция работает с копией переданного значения, а не с оригинальной переменной. Изменения, сделанные внутри функции, не влияют на оригинальную переменную. Давайтен рассотрим функцию которая пытается модифицировать передаваемое значение:

```zig
fn modifyValue(x: i32) void {
    x = 10; // Изменение копии
    std.debug.print("Внутри функции: {}\n", .{x});
}

pub fn main() void {
    var num: i32 = 5;
    modifyValue(num);
    std.debug.print("Снаружи функции: {}\n", .{num});
}
```

Этот код выведет:

```
Внутри функции: 10
Снаружи функции: 5
```

Как мы видим изменение переменной внутри функции не дало ожидаемых результатов. Это происходит потому, что функция работает с копией переданного значения, а не с самой переменной. Чтобы изменить значение переменной внутри функции, мы должны передать ее по ссылке:

```zig
fn modifyValue(x: *i32) void {
    x.* = 10; // Изменение оригинальной переменной
    std.debug.print("Внутри функции: {}\n", .{x.*});
}

pub fn main() void {
    var num: i32 = 5;
    modifyValue(&num); // Передаём указатель на num
    std.debug.print("Снаружи функции: {}\n", .{num});
}
```

В этом случае мы получим ожидаемый результат:

```
Внутри функции: 10
Снаружи функции: 10
```

Однако это совсем не означает что Zig всегда будет копировать переменные при передаче их в функцию. Компилятор довольно умен и если видит что ваш код не изменяет передаваемые переменные, но при этом Вы передаете структуру, которая занимает довольно много места в памяти, то Zig может решить передать ее по ссылке, чтобы избежать лишних копирований. например если мы передаем в функцию структуру `User`, то Zig может передать ее как указатель с типом `*const User`. Как Вы могли заметить указатель ссылается на константные данные, что позволяет компилятору буть уверенными что Вы не сможете изменить вашу структуру внутри функции.

В Zig нет поддержки дефолтных значений для параметров функций, но вы можете использовать опциональные параметры в функциях. Например, если мы не всегда хотим передавать какой-то аргумент, мы можем использовать опциональный тип:

```zig
const std = @import("std");

fn greet(name: ?[]const u8) void {
    const n = name orelse "Гость";
    std.debug.print("Привет, {s}!\n", .{n});
}

pub fn main() !void {
    greet(null);
    greet("Алиса");
}
```

Этот код выведет следущее:

```
Привет, Гость!
Привет, Алиса!
```

К сожалению, в Zig нет поддержки передачи в функцию переменного числа параметров, но мы можем использовать массивы или срезы для передачи переменного числа аргументов. Так как массивы и срезы в Zig содержат информацию о длине, Вы можете безопасно обработать такие переменные в теле функции:

```zig
const std = @import("std");

fn sum(numbers: []const i32) i32 {
    var total: i32 = 0;
    for (numbers) |num| {
        total += num;
    }
    return total;
}

pub fn main() !void {
    const result = sum(&[_]i32{ 1, 2, 3, 4 });

    std.debug.print("Сумма чисел: {d}\n", .{result});
}
```

Этот код выведет:

```
Сумма чисел: 10
```

Функции могут возвращать значения любых типов. Как мы уже рассматривали в главе 2 в Zig есть тип `void`, который используется для функций, не возвращающих значения. Например, функция, которая просто печатает сообщение на экран, может быть объявлена следующим образом:

```zig
fn print_message(message: []const u8) void {
    std.debug.print("{}", .{message});
}
```

Здесь:
* print_message — имя функции.
* message: []const u8 — параметр функции, который представляет собой строку, передаваемую в функцию.
* void после списка параметров — это возвращаемый тип функции, который указывает, что функция не возвращает никакого значения.

Второй тип данных, который мы рассматривали в главе 2 был тип `noreturn`. Этот тип используется тогда, когда надо указать, что функция никогда не вернет управление, например, когда функция вызывает `std.process.exit` или `@panic`.

```zig
fn exit_with_message(message: []const u8) noreturn {
    print_message(message);
    std.process.exit(1);
}
```

В данном примере после вызова функции `print_message`, функция `exit_with_message` завершает выполнение программы с кодом ошибки 1, используя `std.process.exit(1)`. Это гарантирует, что программа завершится после вывода сообщения об ошибке.

```zig
fn print_message(message: []const u8) void {
    std.debug.print("Error: {s}\n", .{message});
}

fn exit_with_message(message: []const u8) void {
    print_message(message);
    std.process.exit(1);
}
```

### Передача функций и анонимные функции

В Zig функции являются объектами первого класса, что означает, что их можно передавать в другие функции, возвращать из функций и хранить в переменных. Это мощная возможность, которая позволяет создавать гибкие и модульные программы. Для того чтобы передать одну функцию в другую, нам необходимо обьявить тип передаваемой переменной используя ключевое слово `fn` и указав типы передаваемых и возвращаемых значений. Давайте рассмотрим пример:

```zig
fn applyFunction(x: i32, func: fn(i32) i32) i32 {
    return func(x);
}

fn square(x: i32) i32 {
    return x * x;
}

fn double(x: i32) i32 {
    return x * 2;
}

pub fn main() void {
    const result1 = applyFunction(5, square); // Применяем square
    const result2 = applyFunction(5, double); // Применяем double
    std.debug.print("Результаты: {}, {}\n", .{result1, result2});
}
```

Данный прнимер кода выведет:

```
Результаты: 25, 10
```

В нашем примере функция `applyFunction` принимает два аргумента: число `x` и функцию `func`. Функция `applyFunction` вызывает функцию `func` с аргументом `x` и возвращает результат. В зависимости от переданной функции (square или double), applyFunction применяет её к числу.

В Zig также поддерживаются анонимные функции, которые бывают полезны когда передаваемая функция слишком мала, чтобы выделять ее в отдельный код. Например, мы могли бы переписать `applyFunction` следующим образом:

```zig
fn applyFunction(x: i32, func: fn(i32) i32) i32 {
    return func(x);
}

pub fn main() void {
    const result = applyFunction(5, fn(x: i32) i32 {
        return x + 10;
    });
    std.debug.print("Результат: {}\n", .{result});
}
```

Функции могут не только принимать другие функции в качестве параметров, но и возвращать функции. Это бывает удобно для реализации различных стратегий или для создания функций высшего порядка. Например, мы может использовать возвращение функции из функции для реализации такого приема как каррирование. Каррирование — это функциональная техника, при которой функция, принимающая несколько аргументов, преобразуется в последовательность функций, каждая из которых принимает только один аргумент. Каррирование позволяет разбить функцию с несколькими аргументами на цепочку функций, каждая из которых принимает только один аргумент и возвращает новую функцию, ожидающую следующий аргумент. Например, функция `add(a: i32, b: i32) i32` может быть преобразована в `add(a: i32) fn(i32) i32`, где add(5) возвращает функцию, которая принимает b и возвращает 5 + b. Давайте взглянем на код реализующий данную технику:

```zig
fn add(a: i32) fn(i32) i32 {
    return fn(b: i32) i32 {
        return a + b;
    };
}

pub fn main() void {
    const addFive = add(5); // Создаём функцию, которая прибавляет 5
    const result = addFive(3); // Вызываем её с аргументом 3
    std.debug.print("Результат: {}\n", .{result});
}
```

В данном коде функция `add` реализует механизм каррирования и при вызове вернет функцию, которая будет к переданному аргументу прибавлять значение `a`. Если мы запустим наш код, то увидим результат:

```
Результат: 8
```

В Zig к сожалению нет явной поддержки анонимных (лямбда) функций, но их можно реализовать с помощью использования аннонимных структур. Мы рассмотрим эту технику позднее когда будем говорить про структуры.

### Область видимости функции
По умолчанию все функции, которые вы определяете в своем модуле не доступны из других модулей. Для того чтобы функцию сделать доступной из других модулей, вы можете использовать ключевое слово `pub` перед объявлением функции. Предположим, что у нас есть файл `math.zig`, где мы собрали функции для работы с математическими операциями. Если наша функция в данном модуле будет обьявлена без ключевого слова `pub`, то она будет недоступна из других модулей, а ее можно будет использовать только в файле `math.zig`. Если попытатся вызвать ее из другого модуля компилятор выдаст ошибку. Вот пример:

```zig
// Файл: math.zig

fn add(a: i32, b: i32) i32 {
    return a + b;
}
```

Чтобы исправить наш код, давайте добавим ключевое слово `pub` перед объявлением функции `add`:

```zig
// Файл: math.zig

pub fn add(a: i32, b: i32) i32 {
    return a + b;
}

// Файл: main.zig

const math = @import("math.zig");

pub fn main() void {
    const result = math.add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Ключевое слово `pub` в Zig — это простой, но мощный инструмент для управления видимостью функций и других элементов. Оно помогает создавать модульные и безопасные программы, четко разделяя публичный API и внутреннюю реализацию. Используйте pub для экспорта функций, которые должны быть доступны извне, и оставляйте остальные функции приватными для улучшения инкапсуляции и читаемости кода.

### Экспорт и импорт функций для использования в других языках программирования
В Zig ключевые слова `extern` и `export` используются для взаимодействия с внешним миром — другими языками программирования или системами. Они позволяют указывать, как функции должны быть видимы за пределами текущего модуля или даже за пределами программы (например, при взаимодействии с C или другими языками). Давайте разберем их подробнее.

Иногда бывает полезно сделать доступной вашу функцию не только для других модулей кода на Zig, но и для других языков программирования, используя FFI (Foreign Function Interface). Для этого вы можете использовать ключевое слово `export`. Это полезно, если вы создаете библиотеку на Zig, которую хотите использовать в других проектах. Например чтобы сделать доступной функцию `add`, вы можете использовать следующий код:

```zig
// Экспортируем функцию для использования в C
export fn add(a: c_int, b: c_int) c_int {
    return a + b;
}
```
Важный момент: типы переменных используемых в функции должны быть совместимы с тем языком, в который вы хотите экспортировать вашу функцию. В данном примере мы используем типы совместимые с языком C, но об этом мы поговорим позднее когда будем обсуждать интеграцию Zig и C.

Ключевое слово extern используется для объявления функций, которые определены вне Zig (например, в C или других языках). Это позволяет Zig вызывать функции из внешних библиотек или системных API.

Предположим, у нас есть C-библиотека с функцией add, которая складывает два числа:

```c
// Файл: math.c
int add(int a, int b) {
    return a + b;
}
```

Чтобы вызвать эту функцию из Zig, нужно объявить её с ключевым словом extern:

```zig
// Файл: main.zig

// Объявляем внешнюю функцию
extern fn add(a: c_int, b: c_int) c_int;

pub fn main() void {
    const result = add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Здесь мы используем ключевое слово extern для объявления функции add, которая определена в C-библиотеке. Это позволяет Zig вызывать эту функцию из своего кода. Важно чтобы типы данных в `extern` функциях были совместимы с внешним языком (например, c_int, c_void и т.д.). Вторым важным моментом является то, что имя функции и её сигнатура (типы аргументов и возвращаемого значения) должны точно совпадать с тем, как она объявлена во внешней библиотеке

### Встраиваемые функции
В Zig ключевое слово `inline` используется для подсказки компилятору, что функцию следует "встроить" (inline) в месте её вызова. Это означает, что вместо вызова функции как отдельной сущности, её код будет вставлен непосредственно в то место, где она вызывается. Это может привести к оптимизации производительности, особенно для небольших функций, которые вызываются часто.

Для того чтобы обьявить вашу функцию как встраеиваемую, используйте ключевое слово inline перед объявлением функции. Это подсказка компилятору, что функцию следует встроить. Однако стоит помнить, что `inline` — это именно подсказка, а не строгое указание. Компилятор может проигнорировать её, если сочтёт, что встраивание неэффективно. Давайте посмотрим на примере:

```zig
inline fn add(a: i32, b: i32) i32 {
    return a + b;
}

pub fn main() void {
    const result = add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Для чего может быть полезно использовать встраивание функций:
* **Уменьшение накладных расходов**: Встраивание устраняет необходимость в вызове функции, что может быть полезно для небольших функций, вызываемых часто.
* **Оптимизация производительности**: Встроенные функции могут быть оптимизированы компилятором более эффективно, особенно если они работают с константами или небольшими данными.
* **Упрощение отладки**: Встроенные функции могут сделать код более линейным, что упрощает его анализ и отладку.

Однако надо быть осторожным со встраиванием функций, так как это может привести к увеличению размера исполняемого файла.

### Рекурсивные функции
Рекурсия — это мощный инструмент в программировании, который позволяет функции вызывать саму себя для решения задачи. В Zig рекурсивные функции поддерживаются на уровне языка и могут быть использованы для реализации сложных алгоритмов, таких как обход деревьев, вычисление факториалов или решение задач с разделяй и властвуй.

Один из классических примеров рекурсии — вычисление факториала числа. Факториал числа n (обозначается как n!) — это произведение всех положительных целых чисел от 1 до n.

```zig
fn factorial(n: u32) u32 {
    if (n == 0) {
        return 1; // Базовый случай
    }
    return n * factorial(n - 1); // Рекурсивный случай
}

pub fn main() void {
    const result = factorial(5);
    std.debug.print("Факториал 5: {}\n", .{result});
}
```

Этот код выведет:

```
Факториал 5: 120
```

Рекурсивная функция всегда должна иметь базовый случай — условие, при котором рекурсия прекращается. Без базового случая функция будет вызывать себя бесконечно, что приведёт к переполнению стека. Как мы уже знаем каждый вызов рекурсивной функции добавляет новый кадр стека, который содержит локальные переменные и состояние функции. Если рекурсия слишком глубокая, это может привести к переполнению стека. В Zig, как и в других языках, важно следить за глубиной рекурсии.

Хвостовая рекурсия — это рекурсия, в которой рекурсивный вызов является последней операцией перед возвратом результата. В таких случаях компилятор может оптимизировать выполнение и не сохранять промежуточные вызовы в стеке, превращая рекурсию в обычный цикл.

```zig
const std = @import("std");

// Хвостовая рекурсивная функция вычисления факториала
fn factorial(n: u32, acc: u32) u32 {
    if (n == 0) return acc;
    return @call(.{ .modifier = .always_tail }, factorial, .{ n - 1, acc * n });
}

pub fn main() void {
    const result = factorial(5, 1);
    std.debug.print("5! = {}\n", .{result}); // Вывод: 5! = 120
}
```

В данном коде мы используем дополнительный параметр `acc`, который хранит промежуточный результат. Рекурсивный вызов является последней операцией в функции, что позволяет компилятору оптимизировать его превратив в цикл `for`. По умолчанию Zig может не всегда оптимизировать хвостовую рекурсию. Использование `.always_tail` гарантирует, что рекурсия будет оптимизирована, а если это невозможно, компилятор выдаст ошибку.
