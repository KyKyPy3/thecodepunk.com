---
title: Функции, перечисления и работа с ошибками
date: 2025-03-07 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - function
  - errors
  - enum
  - union
---

В этой главе мы рассмотрим, как объявлять и использовать функции в Zig, а также изучим их особенности. Во второй части главы мы затронем тему работы с перечислениями и в частности их использование для обратотки ошибок. В Zig функции могут возвращать не только результат вычислений, но и ошибки, если что-то идет не так. Механизм обработки ошибок в Zig имеет сходства с подходом, используемым в языке Rust, но при этом обладает своими уникальными особенностями.

## Функции
Функции — это один из основных строительных блоков в программировании. Они позволяют организовывать код в повторно используемые и модульные блоки, что делает программы более структурированными и удобными для поддержки. Zig не является исключением: в этом языке функции играют ключевую роль, предоставляя разработчикам мощные и гибкие инструменты для работы с кодом.

### Объявление функций
В Zig функция объявляется с использованием ключевого слова `fn`. Базовая структура функции выглядит следующим образом:

```zig
fn имя_функции(параметры) возвращаемый_тип {
    // Тело функции
}
```

Например, простая функция, которая складывает два числа выглядит так:

```zig
fn add(a: i32, b: i32) i32 {
    return a + b;
}
```

Здесь:
* add — имя функции.
* a: i32 и b: i32 — параметры функции, оба имеют тип i32 (32-битное целое число со знаком).
* i32 после списка параметров — это возвращаемый тип функции.
* return a + b; — возвращает сумму a и b.

Для того чтобы вызвать функцию, мы используем ее имя и передаем ей аргументы в круглых скобках. Например, чтобы сложить два числа 3 и 5, мы вызываем функцию `add` следующим образом:

```zig
const result = add(3, 5);
```

При вызове функции, как мы уже знаем из главы про стек, компилятор создаст для нас стековый фрейм, где разместит все локальные переменные функции и переданные ей аргументы. Аргументы функции будут размещены на стеке в порядке справа налево. Для небольших функций компилятор может применить оптимизацию и передать параметры функции через регистры процессора.

### Передача параметров функции
Функции в Zig, как и в других языках программирования, могут принимать параметры, которые передаются в них при вызове. Однако в Zig есть несколько особенностей, связанных с передачей параметров, которые делают этот язык гибким и мощным.

По умолчанию в Zig параметры передаются по значению. Это означает, что функция работает с копией переданного значения, а не с оригинальной переменной. Изменения, сделанные внутри функции, не влияют на оригинальную переменную. Давайте рассмотрим функцию, которая пытается модифицировать передаваемое значение:

```zig
fn modifyValue(x: i32) void {
    x = 10; // Изменение копии
    std.debug.print("Внутри функции: {}\n", .{x});
}

pub fn main() void {
    var num: i32 = 5;
    modifyValue(num);
    std.debug.print("Снаружи функции: {}\n", .{num});
}
```

Этот код выведет:

```
Внутри функции: 10
Снаружи функции: 5
```

Как мы видим изменение переменной внутри функции не дало ожидаемых результатов. Это происходит потому, что функция работает с копией переданного значения, а не с самой переменной. Чтобы изменить значение переменной внутри функции, мы должны передать ее по ссылке:

```zig
fn modifyValue(x: *i32) void {
    x.* = 10; // Изменение оригинальной переменной
    std.debug.print("Внутри функции: {}\n", .{x.*});
}

pub fn main() void {
    var num: i32 = 5;
    modifyValue(&num); // Передаём указатель на num
    std.debug.print("Снаружи функции: {}\n", .{num});
}
```

В этом случае мы получим ожидаемый результат:

```
Внутри функции: 10
Снаружи функции: 10
```

Однако это не значит, что Zig всегда копирует переменные при передаче их в функцию. Компилятор достаточно умён и, если видит, что передаваемая переменная не изменяется в коде, но при этом является структурой, занимающей много памяти, он может автоматически передать её по ссылке вместо создания копии. Это позволяет избежать лишних затрат памяти и увеличения производительности. Например, если мы передаём в функцию структуру `User`, Zig может преобразовать её в указатель с типом `*const User`. Это означает, что внутри функции мы будем работать не с копией структуры, а с её исходными данными.

Важно отметить, что указатель ссылается на константные данные (`*const User`), что гарантирует неизменность структуры внутри функции. Благодаря этому компилятор может быть уверен, что переданные данные не будут случайно изменены, а программа останется безопасной и предсказуемой.

В Zig нет поддержки дефолтных значений для параметров функций, но вы можете использовать опциональные параметры в функциях. Например, если мы не всегда хотим передавать какой-то аргумент, мы можем использовать опциональный тип:

```zig
const std = @import("std");

fn greet(name: ?[]const u8) void {
    const n = name orelse "Гость";
    std.debug.print("Привет, {s}!\n", .{n});
}

pub fn main() !void {
    greet(null);
    greet("Алиса");
}
```

Этот код выведет следущее:

```
Привет, Гость!
Привет, Алиса!
```

К сожалению, в Zig нет поддержки передачи в функцию переменного числа параметров, но мы можем использовать массивы или срезы для передачи переменного числа аргументов. Так как массивы и срезы в Zig содержат информацию о размере, Вы можете безопасно обработать такие переменные в теле функции:

```zig
const std = @import("std");

fn sum(numbers: []const i32) i32 {
    var total: i32 = 0;
    for (numbers) |num| {
        total += num;
    }
    return total;
}

pub fn main() !void {
    const result = sum(&[_]i32{ 1, 2, 3, 4 });

    std.debug.print("Сумма чисел: {d}\n", .{result});
}
```

Этот код выведет:

```
Сумма чисел: 10
```

Функции могут возвращать значения любых типов. Как мы уже рассматривали в главе 2 в Zig есть тип `void`, который используется для функций, не возвращающих значения. Например, функция, которая просто печатает сообщение на экран, может быть объявлена следующим образом:

```zig
fn print_message(message: []const u8) void {
    std.debug.print("{}", .{message});
}
```

Здесь:
* print_message — имя функции.
* message: []const u8 — параметр функции, который представляет собой строку, передаваемую в функцию.
* void после списка параметров — это возвращаемый тип функции, который указывает, что функция не возвращает никакого значения.

Второй тип данных, который мы рассматривали в главе 2 был тип `noreturn`. Этот тип используется тогда, когда надо указать, что функция никогда не вернет управление, например, когда функция вызывает `std.process.exit` или `@panic`.

```zig
fn exit_with_message(message: []const u8) noreturn {
    print_message(message);
    std.process.exit(1);
}
```

В данном примере после вызова функции `print_message`, функция `exit_with_message` завершает выполнение программы с кодом ошибки 1, используя `std.process.exit(1)`. Это гарантирует, что программа завершится после вывода сообщения об ошибке.

```zig
fn print_message(message: []const u8) void {
    std.debug.print("Error: {s}\n", .{message});
}

fn exit_with_message(message: []const u8) void {
    print_message(message);
    std.process.exit(1);
}
```

### Передача функций

В Zig функции являются объектами первого класса, что означает, что их можно передавать в другие функции, возвращать из функций и хранить в переменных. Это мощная возможность, которая позволяет создавать гибкие и модульные программы. Для того, чтобы передать одну функцию в другую, нам необходимо обьявить тип передаваемой переменной используя ключевое слово `fn` и указав типы передаваемых и возвращаемых значений. Давайте рассмотрим пример:

```zig
fn applyFunction(x: i32, func: fn(i32) i32) i32 {
    return func(x);
}

fn square(x: i32) i32 {
    return x * x;
}

fn double(x: i32) i32 {
    return x * 2;
}

pub fn main() void {
    const result1 = applyFunction(5, square); // Применяем square
    const result2 = applyFunction(5, double); // Применяем double
    std.debug.print("Результаты: {}, {}\n", .{result1, result2});
}
```

Данный прнимер кода выведет:

```
Результаты: 25, 10
```

В нашем примере функция `applyFunction` принимает два аргумента: число `x` и функцию `func`. Функция `applyFunction` вызывает функцию `func` с аргументом `x` и возвращает результат. В зависимости от переданной функции (square или double), applyFunction применяет её к числу.

Функции могут не только принимать другие функции в качестве параметров, но и возвращать функции. Это бывает удобно для реализации различных стратегий или для создания функций высшего порядка. Например, мы может использовать возвращение функции из функции для реализации такого приема как каррирование. Каррирование — это функциональная техника, при которой функция, принимающая несколько аргументов, преобразуется в последовательность функций, каждая из которых принимает только один аргумент.

Каррирование позволяет разбить функцию с несколькими аргументами на цепочку функций, каждая из которых принимает только один аргумент и возвращает новую функцию, ожидающую следующий аргумент. Например, функция `add(a: i32, b: i32) i32` может быть преобразована в `add(a: i32) fn(i32) i32`, где add(5) возвращает функцию, которая принимает b и возвращает 5 + b. Давайте взглянем на код реализующий данную технику:

```zig
fn add(a: i32) fn(i32) i32 {
    return fn(b: i32) i32 {
        return a + b;
    };
}

pub fn main() void {
    const addFive = add(5); // Создаём функцию, которая прибавляет 5
    const result = addFive(3); // Вызываем её с аргументом 3
    std.debug.print("Результат: {}\n", .{result});
}
```

В данном коде функция `add` реализует механизм каррирования и при вызове вернет функцию, которая будет к переданному аргументу прибавлять значение `a`. Если мы запустим наш код, то увидим результат:

```
Результат: 8
```

В Zig к сожалению нет явной поддержки анонимных (лямбда) функций, но их можно реализовать с помощью использования аннонимных структур. Мы рассмотрим эту технику позднее когда будем говорить про структуры.

### Область видимости функции
По умолчанию все функции, которые вы определяете в своем модуле не доступны из других модулей. Для того чтобы функцию сделать доступной из других модулей, вы можете использовать ключевое слово `pub` перед объявлением функции. Предположим, что у нас есть файл `math.zig`, где мы собрали функции для работы с математическими операциями. Если наша функция в данном модуле будет обьявлена без ключевого слова `pub`, то она будет недоступна из других модулей, а ее можно будет использовать только в файле `math.zig`. Если попытатся вызвать ее из другого модуля компилятор выдаст ошибку. Вот пример:

```zig
// Файл: math.zig

fn add(a: i32, b: i32) i32 {
    return a + b;
}
```

Чтобы исправить наш код, давайте добавим ключевое слово `pub` перед объявлением функции `add`:

```zig
// Файл: math.zig

pub fn add(a: i32, b: i32) i32 {
    return a + b;
}

// Файл: main.zig

const math = @import("math.zig");

pub fn main() void {
    const result = math.add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Ключевое слово `pub` в Zig — это простой, но мощный инструмент для управления видимостью функций и других элементов. Оно помогает создавать модульные и безопасные программы, четко разделяя публичный API и внутреннюю реализацию. Используйте pub для экспорта функций, которые должны быть доступны извне, и оставляйте остальные функции приватными для улучшения инкапсуляции и читаемости кода.

### Экспорт и импорт функций для использования в других языках программирования
В Zig ключевые слова `extern` и `export` используются для взаимодействия с внешним миром — другими языками программирования или системами. Они позволяют указывать, как функции должны быть видимы за пределами текущего модуля или даже за пределами программы (например, при взаимодействии с C или другими языками). Давайте разберем их подробнее.

Иногда бывает полезно сделать доступной вашу функцию не только для других модулей кода на Zig, но и для других языков программирования, используя FFI (Foreign Function Interface). Для этого вы можете использовать ключевое слово `export`. Это полезно, если вы создаете библиотеку на Zig, которую хотите использовать в других проектах. Например чтобы сделать доступной функцию `add`, вы можете использовать следующий код:

```zig
// Экспортируем функцию для использования в C
export fn add(a: c_int, b: c_int) c_int {
    return a + b;
}
```
Важный момент: типы переменных используемых в функции должны быть совместимы с тем языком, в который вы хотите экспортировать вашу функцию. В данном примере мы используем типы совместимые с языком C, но об этом мы поговорим позднее когда будем обсуждать интеграцию Zig и C.

Ключевое слово extern используется для объявления функций, которые определены вне Zig (например, в C или других языках). Это позволяет Zig вызывать функции из внешних библиотек или системных API.

Предположим, у нас есть C-библиотека с функцией add, которая складывает два числа:

```c
// Файл: math.c
int add(int a, int b) {
    return a + b;
}
```

Чтобы вызвать эту функцию из Zig, нужно объявить её с ключевым словом extern:

```zig
// Файл: main.zig

// Объявляем внешнюю функцию
extern fn add(a: c_int, b: c_int) c_int;

pub fn main() void {
    const result = add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Здесь мы используем ключевое слово extern для объявления функции add, которая определена в C-библиотеке. Это позволяет Zig вызывать эту функцию из своего кода. Важно чтобы типы данных в `extern` функциях были совместимы с внешним языком (например, c_int, c_void и т.д.). Вторым важным моментом является то, что имя функции и её сигнатура (типы аргументов и возвращаемого значения) должны точно совпадать с тем, как она объявлена во внешней библиотеке

### Встраиваемые функции
В Zig ключевое слово `inline` используется для подсказки компилятору, что функцию следует "встроить" (inline) в месте её вызова. Это означает, что вместо вызова функции как отдельной сущности, её код будет вставлен непосредственно в то место, где она вызывается. Это может привести к оптимизации производительности, особенно для небольших функций, которые вызываются часто.

Для того чтобы обьявить вашу функцию как встраеиваемую, используйте ключевое слово inline перед объявлением функции. Это подсказка компилятору, что функцию следует встроить. Однако стоит помнить, что `inline` — это именно подсказка, а не строгое указание. Компилятор может проигнорировать её, если сочтёт, что встраивание неэффективно. Давайте посмотрим на примере:

```zig
inline fn add(a: i32, b: i32) i32 {
    return a + b;
}

pub fn main() void {
    const result = add(5, 3);
    std.debug.print("Результат сложения: {}\n", .{result});
}
```

Для чего может быть полезно использовать встраивание функций:
* **Уменьшение накладных расходов**: Встраивание устраняет необходимость в вызове функции, что может быть полезно для небольших функций, вызываемых часто.
* **Оптимизация производительности**: Встроенные функции могут быть оптимизированы компилятором более эффективно, особенно если они работают с константами или небольшими данными.
* **Упрощение отладки**: Встроенные функции могут сделать код более линейным, что упрощает его анализ и отладку.

Однако надо быть осторожным со встраиванием функций, так как это может привести к увеличению размера исполняемого файла.

### Рекурсивные функции
Рекурсия — это мощный инструмент в программировании, который позволяет функции вызывать саму себя для решения задачи. В Zig рекурсивные функции поддерживаются на уровне языка и могут быть использованы для реализации сложных алгоритмов, таких как обход деревьев, вычисление факториалов или решение задач с разделяй и властвуй.

Один из классических примеров рекурсии — вычисление факториала числа. Факториал числа n (обозначается как n!) — это произведение всех положительных целых чисел от 1 до n.

```zig
fn factorial(n: u32) u32 {
    if (n == 0) {
        return 1; // Базовый случай
    }
    return n * factorial(n - 1); // Рекурсивный случай
}

pub fn main() void {
    const result = factorial(5);
    std.debug.print("Факториал 5: {}\n", .{result});
}
```

Этот код выведет:

```
Факториал 5: 120
```

Рекурсивная функция всегда должна иметь базовый случай — условие, при котором рекурсия прекращается. Без базового случая функция будет вызывать себя бесконечно, что приведёт к переполнению стека. Как мы уже знаем каждый вызов рекурсивной функции добавляет новый кадр стека, который содержит локальные переменные и состояние функции. Если рекурсия слишком глубокая, это может привести к переполнению стека. В Zig, как и в других языках, важно следить за глубиной рекурсии.

Хвостовая рекурсия — это рекурсия, в которой рекурсивный вызов является последней операцией перед возвратом результата. В таких случаях компилятор может оптимизировать выполнение и не сохранять промежуточные вызовы в стеке, превращая рекурсию в обычный цикл.

```zig
const std = @import("std");

// Хвостовая рекурсивная функция вычисления факториала
fn factorial(n: u32, acc: u32) u32 {
    if (n == 0) return acc;
    return @call(.{ .modifier = .always_tail }, factorial, .{ n - 1, acc * n });
}

pub fn main() void {
    const result = factorial(5, 1);
    std.debug.print("5! = {}\n", .{result}); // Вывод: 5! = 120
}
```

В данном коде мы используем дополнительный параметр `acc`, который хранит промежуточный результат. Рекурсивный вызов является последней операцией в функции, что позволяет компилятору оптимизировать его превратив в цикл `for`. По умолчанию Zig может не всегда оптимизировать хвостовую рекурсию. Использование функции @call с параметром `.always_tail` гарантирует, что рекурсия будет оптимизирована, а если это невозможно, компилятор выдаст ошибку.

### Использование @call
В Zig есть встроенная функция @call, которая позволяет вызывать функции с явным указанием способа вызова (calling convention). Это полезно в случаях, когда нужно контролировать, как именно вызывается функция, например, для взаимодействия с низкоуровневыми API или для оптимизации.

@call — это встроенная функция (builtin) в Zig, которая позволяет вызывать другую функцию, явно указывая:
* Способ вызова (calling convention).
* Аргументы функции.
* Возвращаемое значение.

Синтаксис:

```zig
@call(calling_convention, function, arguments)
```

Где:
* calling_convention — способ вызова функции (например, .Auto, .C, .Inline).
* function — функция, которую нужно вызвать.
* arguments — кортеж (tuple) аргументов, передаваемых в функцию.

Мы не будем рассматривать все возможные параметры, которые можно передать функции @call, а лишь рассмотрим некоторые из них. Полное описание параметров Вы можете найти в документации к языку Zig.

Список параметров:

* .Always_tail, .NeverTail — позволяет управлять, будет ли компилятор пытаться оптимизировать рекурсивный вызов в цикл `for`.
* .AlwaysInline, NeverInline — позволяет управлять, будет ли функция встроена (inlined) в вызывающую функцию.
* .Auto — Zig автоматически выбирает оптимальный способ вызова функции. Это поведение по умолчанию, которое подходит для большинства случаев

## Перечисления и объединения
Перечисления (enums) и объединения (unions) — это мощные инструменты в Zig, которые позволяют создавать типы данных с ограниченным набором значений или альтернативных представлений. Они особенно полезны для моделирования состояний, обработки ошибок и работы с данными, которые могут принимать разные формы.

### Перечисления (enums)
Перечисления (enums) — это типы данных, которые могут принимать одно из нескольких предопределённых значений. Они полезны для создания ограниченного набора вариантов, например, для представления состояний или категорий. Давайте рассмотрим пример использования перечисления:

```zig
const std = @import("std");

const Color = enum {
    Red,
    Green,
    Blue,
};

pub fn main() void {
    const color = Color.Red;

    switch (color) {
        .Red => std.debug.print("Цвет: Красный\n", .{}),
        .Green => std.debug.print("Цвет: Зелёный\n", .{}),
        .Blue => std.debug.print("Цвет: Синий\n", .{}),
    }
}
```

Вывод:
```
Цвет: Красный
```

В этом примере мы определяем перечисление Color, в котором задаём три возможных значения: Red, Green и Blue. Затем создаём переменную color типа Color и присваиваем ей значение Color.Red. Далее мы используем оператор switch, чтобы проверить, какое значение содержит переменная color, и выводим соответствующее сообщение. Такой способ обработки перечислений называется “сопоставление с образцом” (pattern matching). По умолчанию каждому значению в перечислении присваивается целочисленное значение, начиная с 0. В нашем примере Red имеет значение 0, Green — 1, а Blue — 2.

Если нам не подходят целочисленные значения, которые присваиваются по умолчанию мы можем либо задать начальное значение для первого элемента перечисления, либо использовать атрибуты для задания значений для каждого элемента. Например чтобы сделать перечисление с кодами Http статусов для ответа на запрос мы можем написать следующее перечисление:

```zig
const HttpStatus = enum {
    Ok = 200,
    Created = 201,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
};

pub fn main() void {
    const status = HttpStatus.Ok;
    std.debug.print("Код статуса: {}\n", .{@intFromEnum(status)});
}
```

По умолчанию для значений перечесления будет использоваться тип `u32` (беззнаковое 32-битное целое число). Если мы знаем, что перечисление будет содержать только небольшое количество элементов, то можно использовать тип `u8` (беззнаковое 8-битное целое число) или `u16` (беззнаковое 16-битное целое число). Например:

```zig
const Color = enum(u8) {
    Red,
    Green,
    Blue,
};

pub fn main() void {
    const color = Color.Red;
    std.debug.print("Цвет: {}\n", .{@intFromEnum(color)});
}
```

Такое определение перечисления позволит более экономно расходовать память используемую для хранения значений перечисления.

В Zig встроенная функция `@tagName` позволяет получить строковое представление значения перечисления (enum). Это особенно полезно для отладки, логирования или вывода значений перечисления в удобочитаемом виде. Рассмотрим простой пример перечисления и использование @tagName для получения строкового представления его значений:

```zig
const Direction = enum {
    North,
    South,
    East,
    West,
};

pub fn main() void {
    const direction = Direction.North;
    std.debug.print("Направление: {}\n", .{@tagName(direction)});
}
```

Этот код выведет:

```
Направление: North
```

В Zig перечисления могут содержать функции привязанные к перечислению. Это может быть полезно если Вы хотите сделать Ваш код более выразительным и понятным. Например, можно добавить функцию `toString` к перечислению `Direction`, которая будет возвращать строковое представление направления:

```zig
const Direction = enum {
    North,
    South,
    East,
    West,

    fn toString(self: Direction) []const u8 {
        return switch (self) {
            Direction.North => "North",
            Direction.South => "South",
            Direction.East => "East",
            Direction.West => "West",
        };
    }
};

pub fn main() void {
    const direction = Direction.North;
    std.debug.print("Направление: {}\n", .{direction.toString()});
}
```

Этот код выведет:

```
Направление: North
```
