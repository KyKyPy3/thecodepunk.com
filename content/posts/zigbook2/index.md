---
title: Переменные и константы
date: 2025-02-21 00:11:00
showTableOfContents: true
showComments: true
tags:
  - zig
  - zigbook
---
В языке Zig переменные и константы используются для хранения данных. Zig поддерживает строгую типизацию и требует явной инициализации переменных перед использованием, что предотвращает многие ошибки на этапе компиляции. Это делает код более предсказуемым и безопасным, так как разработчики не могут случайно использовать неинициализированные переменные.

## Объявление переменных
Переменные в языке программирования Zig объявляются с использованием ключевого слова `var`. Это означает, что их значение можно изменять в процессе выполнения программы, что делает их удобными для хранения и обработки данных.

При создании переменных в Zig принято использовать так называемую “змеиную нотацию” (snake_case). Это означает, что все слова в имени переменной пишутся с маленькой буквы и разделяются символом подчеркивания (_). Такой стиль именования улучшает читаемость кода и делает его более понятным.

В общем виде объявление переменной выглядит так:

```zig
var имя_переменной: тип = значение;
```

Здесь:
* var — ключевое слово, указывающее, что создается изменяемая переменная.
* имя_переменной — уникальное название переменной, следующее правилам именования.
* тип — тип данных, который будет храниться в переменной. В Zig типизация строгая, поэтому его необходимо указывать явно.
* значение — начальное значение, присваиваемое переменной.

Давайте рассмотрим несколько примеров:

```zig
var age: i32 = 0;
var name: []const u8 = "Алиса";
var is_active: bool = true;
```

В данном примере мы определили три переменных с типами целого числа, строки и булевой переменной, но о типах мы поговорим в следующей главе, а пока давайте остановимся только на определении переменных.

В языке Zig можно объявлять сразу несколько переменных в одной строке, что помогает сделать код более компактным и удобным, особенно если эти переменные логически связаны между собой. Это достигается с помощью последовательного объявления переменных через запятую. Однако важно учитывать, что каждая переменная должна иметь свой тип, если он явно указывается.

Рассмотрим конкретный пример, в котором объявляются три переменные — длина, ширина и площадь, которые могут использоваться, например, для хранения параметров прямоугольника:

```zig
var length: u32 = 10, width: u32 = 5, area: u32 = length * width;
```

Здесь сразу три переменные объявлены в одной строке, что делает код более лаконичным. Однако, несмотря на такую возможность, разработчикам рекомендуется использовать этот подход с осторожностью, чтобы не ухудшить читаемость кода, особенно если переменные имеют сложные и длинные имена.

При объявлении переменной в языке Zig не всегда необходимо явно указывать ее тип. Это возможно благодаря механизму вывода типа (type inference), который автоматически определяет тип переменной на основе ее начального значения. Это делает код более кратким и удобочитаемым, особенно в простых случаях.

```zig
var age = 30; // Zig выведет тип переменной как i32
var pi = 3.14159; // Zig выведет тип переменной как f64
var message = "Привет, мир!"; // Zig выведет тип переменной как []const u8
```

Однако важно понимать, что в некоторых ситуациях такой подход может привести к неожиданным результатам. Например, если присвоить переменной числовое значение без явного указания типа, Zig может интерпретировать его как comptime_int (число, вычисляемое во время компиляции). Если попытатся изменить потом такую переменную, то мы получим ошибку компиляции:

```zig
const std = @import("std");

pub fn main() !void {
    var age = 0;

    std.debug.print("Age: {d}, type: {}\n", .{ age, @TypeOf(age) });

    age += 1;
}

# zig build run
run
└─ run vars
   └─ zig build-exe vars Debug native 1 errors
src/main.zig:4:9: error: variable of type 'comptime_int' must be const or comptime
    var age = 0;
        ^~~
src/main.zig:4:9: note: to modify this variable at runtime, it must be given an explicit fixed-size number type
```

В этом случае Zig автоматически рассматривает переменную age как comptime_int (число, вычисляемое во время компиляции), а такие переменные не могут изменяться во время выполнения программы.

Такое поведение может быть непривычным для разработчиков, знакомых с другими языками программирования. Однако оно соответствует философии Zig, согласно которой намерения программиста должны быть четко выражены. Чтобы избежать подобных ошибок, рекомендуется явно указывать тип переменной, особенно в больших проектах, где важна предсказуемость кода.

Если мы хотим, чтобы переменная age могла изменяться во время выполнения программы, необходимо явно указать ее тип:

```zig
const std = @import("std");

pub fn main() !void {
    var age: i32 = 0;

    std.debug.print("Age: {d}, type: {}\n", .{ age, @TypeOf(age) });

    age += 1;
}
```

```shell
$ zig build run
Age: 0, type: i32
```

## Изменяемость переменных
Как уже упоминалось переменные изменяемы и Вы можете менять значение переменной сколько угодно раз, но при этом вы не можете изменять тип переменной. Следующий код при компиляциии выведет ошибку:

```zig
var x: i32 = 5;
x = 10; // Изменяем значение нашей перемнной
x += 3; // Теперь x равен 13

var y: i32 = 5;
y = 3.14; // Это приведет к ошибке компиляции
```

В языке Zig каждая переменная, которую вы объявляете в своей программе, предполагается изменяемой. Это означает, что вы должны хотя бы один раз изменить её значение в ходе выполнения программы.

Если же переменная остается неизменной, компилятор Zig обнаружит это еще на этапе компиляции и выдаст предупреждение или ошибку. Он предложит вам заменить объявленную переменную на константу (const), поскольку в таком случае её использование будет более корректным. Это помогает писать более чистый и безопасный код, исключая ненужные изменяемые переменные.

Такой подход заставляет разработчика осознанно выбирать между изменяемыми (var) и неизменяемыми (const) значениями, что делает код более предсказуемым и понятным:

```zig
var y: i32 = 5;

std.debug.print("Y: {}\n", .{y});

$ zig build
install
└─ install hello
   └─ zig build-exe hello Debug native 1 errors
src/main.zig:6:9: error: local variable is never mutated
    var y: i32 = 5;
        ^
src/main.zig:6:9: note: consider using 'const'
```

Язык программирования Zig обладает строгой системой типов и не выполняет неявное приведение типов. Это означает, что если вам нужно работать с переменными разных типов, вам придется явно указывать их тип или использовать приведение типов вручную.

Одним из способов явного указания типа переменной является использование литеральных суффиксов. Они позволяют сразу определить, к какому типу данных принадлежит значение, что делает код более читаемым и предсказуемым.

Литеральные суффиксы представляют собой специальные обозначения, добавляемые к числовым значениям. Например:

```zig
var a = 10; // i32
var b = 10.0; // f64
var c = 10.0f32; // f32
var d = 10u64; // u64
```

Использование суффиксов помогает избежать потенциальных ошибок, связанных с приведением типов, и дает компилятору четкие указания о том, как интерпретировать каждое значение. Это особенно важно при работе с числами разной разрядности и при написании высокопроизводительного кода, где важен строгий контроль над используемыми типами данных.

## Инициализация переменных
В языке программирования Zig вы можете объявлять переменные без их немедленной инициализации, но при этом обязательно должны указать их тип. Однако, прежде чем использовать такую переменную в коде, её необходимо явно инициализировать. Если этого не сделать, компилятор Zig выдаст ошибку во время компиляции, предотвращая возможные проблемы, связанные с использованием неинициализированных данных.

```zig
var uninitialized: i32;
// error: variable 'uninitialized' has no initializer
```

В этом примере переменная uninitialized объявлена, но ей не присвоено начальное значение. Из-за этого компилятор Zig выдаст ошибку и не позволит скомпилировать программу. Чтобы избежать таких ситуаций, Zig требует явного задания начального значения, так как, если по какой-то причине ваш код использует эту переменную, пока она не инициализирована, у вас будет неопределенное поведение и серьезные ошибки в вашей программе.

## Переменные вычисляемые во время компиляции
Zig предлагает интересную возможность — переменные, которые вычисляются во время компиляции, но при этом могут использоваться в местах, где обычные константы не подходят. Это позволяет выполнять сложные вычисления еще до запуска программы, что может значительно ускорить её выполнение. Давайте рассмотрим пример:

```zig
fn generateFibonacci(comptime n: usize) [n]u64 {
    comptime var fibs: [n]u64 = undefined;
    fibs[0] = 1;
    fibs[1] = 1;

    comptime var i: usize = 2;
    while (i < n) : (i += 1) {
        fibs[i] = fibs[i - 1] + fibs[i - 2];
    }

    return fibs;
}

const fib10 = generateFibonacci(10); // Числа Фибоначчи вычисляются во время компиляции
```

Здесь функция generateFibonacci создает массив из n чисел Фибоначчи. Так как аргумент n объявлен как comptime, Zig вычислит значения еще во время компиляции. Переменная fib10 будет содержать первые 10 чисел Фибоначчи, и во время выполнения программы они уже будут готовы, что избавляет от необходимости рассчитывать их в реальном времени.

## Константы
В языке Zig константы отличаются от переменных тем, что их значение неизменно и известно еще на этапе компиляции. Это делает код более предсказуемым и безопасным. Для объявления константы используется ключевое слово `const`, а общий синтаксис выглядит следующим образом:

```zig
const имя: тип = значение;
```

Давайте рассмотрим несколько примеров:

```zig
const gravity: f64 = 9.81;
const greeting = "Welcome to Zig!";
```

Если вы попытаетесь изменить значение константы после её объявления, компилятор выдаст ошибку:

```zig
const gravity: f64 = 9.81;

gravity = 10.0; // Ошибка! Константы нельзя изменять.
```

Также как и с переменными при объявлении константы мы можем опустить указание типа, позволив компилятору вывести его за нас:

```zig
const GREETING = "Hello, World!"; // Zig выведет тип как *const [13:0]u8
const MAX_THREADS = 8; // Zig выведет тип как comptime_int
```

Не беспокойтесь, если тип MAX_THREADS (comptime_int) выглядит незнакомым — мы разберем это подробнее позже, когда будем говорить о вычислениях во время компиляции.

Одна из мощных особенностей Zig заключается в том, что все константы вычисляются во время компиляции. Это означает, что вы можете использовать сложные выражения или даже вызовы функций, если они могут быть вычисленны во время компиляции. При этом константы вычисляемые на этапе компиляции имеют "ленивую" инициализацию, что означает, что их значение вычисляется только при первом обращении к ним. Давайте рассмотрим пример:

```zig
const BUFFER_SIZE = 1024 * 1024; // 1 MB

fn comptime_sqrt(x: f64) f64 {
    return @sqrt(x);
}

const SQRT_2 = comptime_sqrt(2.0);
```

## Использование переменных и констант
В языке Zig каждая объявленная переменная или константа обязательно должна использоваться в коде. Это означает, что если вы объявите переменную, но нигде её не примените — компилятор выдаст ошибку. Это правило помогает поддерживать чистоту кода и предотвращает накопление неиспользуемых переменных, которые могут запутывать разработчика и делать программу сложнее для понимания.

Если переменная или константа не участвует в выражениях и не передается в функции, компилятор Zig сообщит об этом:

```zig
const unused_var = 42; // Ошибка: переменная не используется
```

Иногда функции возвращают значения, которые вам не нужны. Например, если функция выполняет какие-то действия, но её возвращаемое значение не имеет для вас значения, вы можете явно “отбросить” его. В Zig для этого используется специальная переменная `_`.

```zig
const age = 15;
_ = age; // Отбрасываем значение
```

Когда переменная присваивается `_`, Zig считает её ненужной и уничтожает. Это позволяет избежать ошибки компиляции, если переменная не будет использоваться далее в коде. После того как вы присвоили значение `_`, использовать переменную снова нельзя. Попытка обратиться к ней приведет к ошибке компиляции

```zig
const age = 15;
_ = age;
// Использование отброшенного значения!
std.debug.print("{d}\n", .{age + 2}); // Ошибка компиляции
```

## Затенение переменных
В Zig можно объявить новую переменную с тем же именем, что и у существующей переменной. В этом случае говорят, что первая переменная «затеняется» второй, то есть вторая переменная — это то, что увидит компилятор, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не будет затенена, либо не закончится область видимости.

```zig
const x = 10;
{
    var x = 20; // Это затеняет внешнюю переменную x
    assert(x == 20);
}
assert(x == 10); // Здесь x ссылается на внешнюю переменную
```

В данном примере, во вложенном блоке переменная `x` затеняет переменную `x` из внешнего блока. Это означает, что в блоке `{}` переменная `x` будет иметь значение `20`, а во внешнем блоке переменная `x` будет иметь значение `10`. Затенение переменных может быть полезным инструментом, но его следует использовать с осторожностью, чтобы избежать путаницы и ошибок в коде. Четкое понимание области видимости и затенения поможет вам писать более чистый и понятный код.
