---
title: Переменные и константы
date: 2025-02-21 00:11:00
showTableOfContents: true
showComments: true
tags:
  - zig
  - zigbook
---
В языке Zig переменные и константы используются для хранения данных. Zig поддерживает строгую типизацию и требует явной инициализации переменных перед использованием, что предотвращает многие ошибки на этапе компиляции. Это делает код более предсказуемым и безопасным, так как разработчики не могут случайно использовать неинициализированные переменные.

## Объявление переменных
Переменные в языке программирования Zig объявляются с использованием ключевого слова `var`. Это означает, что их значение можно изменять в процессе выполнения программы, что делает их удобными для хранения и обработки данных.

При создании переменных в Zig принято использовать так называемую “змеиную нотацию” (snake_case). Это означает, что все слова в имени переменной пишутся с маленькой буквы и разделяются символом подчеркивания (_). Такой стиль именования улучшает читаемость кода и делает его более понятным.

В общем виде объявление переменной выглядит так:

```zig
var имя_переменной: тип = значение;
```

Здесь:
* var — ключевое слово, указывающее, что создается изменяемая переменная.
* имя_переменной — уникальное название переменной, следующее правилам именования.
* тип — тип данных, который будет храниться в переменной. В Zig типизация строгая, поэтому его необходимо указывать явно.
* значение — начальное значение, присваиваемое переменной.

Давайте рассмотрим несколько примеров:

```zig
var age: i32 = 0;
var name: []const u8 = "Алиса";
var is_active: bool = true;
```

В данном примере мы определили три переменных с типами целого числа, строки и булевой переменной, но о типах мы поговорим в следующей главе, а пока давайте остановимся только на определении переменных.

В языке Zig можно объявлять сразу несколько переменных в одной строке, что помогает сделать код более компактным и удобным, особенно если эти переменные логически связаны между собой. Это достигается с помощью последовательного объявления переменных через запятую. Однако важно учитывать, что каждая переменная должна иметь свой тип, если он явно указывается.

Рассмотрим конкретный пример, в котором объявляются три переменные — длина, ширина и площадь, которые могут использоваться, например, для хранения параметров прямоугольника:

```zig
var length: u32 = 10, width: u32 = 5, area: u32 = length * width;
```

Здесь сразу три переменные объявлены в одной строке, что делает код более лаконичным. Однако, несмотря на такую возможность, разработчикам рекомендуется использовать этот подход с осторожностью, чтобы не ухудшить читаемость кода, особенно если переменные имеют сложные и длинные имена.

При объявлении переменной в языке Zig не всегда необходимо явно указывать ее тип. Это возможно благодаря механизму вывода типа (type inference), который автоматически определяет тип переменной на основе ее начального значения. Это делает код более кратким и удобочитаемым, особенно в простых случаях.

```zig
var age = 30; // Zig выведет тип переменной как i32
var pi = 3.14159; // Zig выведет тип переменной как f64
var message = "Привет, мир!"; // Zig выведет тип переменной как []const u8
```

Однако важно понимать, что в некоторых ситуациях такой подход может привести к неожиданным результатам. Например, если присвоить переменной числовое значение без явного указания типа, Zig может интерпретировать его как comptime_int или comptime_float (число, вычисляемое во время компиляции). Если попытаться изменить потом такую переменную, то мы получим ошибку компиляции:

```zig
const std = @import("std");

pub fn main() !void {
    var age = 0;

    std.debug.print("Age: {d}, type: {}\n", .{ age, @TypeOf(age) });

    age += 1;
}
```

```
# zig build run
run
└─ run vars
   └─ zig build-exe vars Debug native 1 errors
src/main.zig:4:9: error: variable of type 'comptime_int' must be const or comptime
    var age = 0;
        ^~~
src/main.zig:4:9: note: to modify this variable at runtime, it must be given an explicit fixed-size number type
```

В этом случае Zig автоматически рассматривает переменную age как comptime_int (число, вычисляемое во время компиляции), а такие переменные не могут изменяться во время выполнения программы.

Такое поведение может быть непривычным для разработчиков, знакомых с другими языками программирования. Однако оно соответствует философии Zig, согласно которой намерения программиста должны быть четко выражены. Чтобы избежать подобных ошибок, рекомендуется явно указывать тип переменной, особенно в больших проектах, где важна предсказуемость кода.

Если мы хотим, чтобы переменная `age` могла изменяться во время выполнения программы, необходимо явно указать ее тип:

```zig
const std = @import("std");

pub fn main() !void {
    var age: i32 = 0;

    std.debug.print("Age: {d}, type: {}\n", .{ age, @TypeOf(age) });

    age += 1;
}
```

```
$ zig build run
Age: 0, type: i32
```

Важно отметить, что вывод типа переменной может выполнятся даже в более сложных случаях, когда тип переменной может быть выведен из двух переменных разного типа. Давайте рассмотрим следующий код:

```zig
const std = @import("std");

pub fn main() void {
    const age: u8 = 25;
    const child_salary: u8 = 100;
    const adult_salary: u16 = 2000;

    const total_salary = if (age < 18) child_salary else adult_salary;

    std.debug.print("Тип total_salary: {}\n", .{@TypeOf(total_salary)});
}
```

Данный код выведет:

```
Тип total_salary: u16
```

Как мы видим Zig проанализировал наш код и вывел тип переменной `total_salary` как `u16`. Это происходит потому, что тип переменной `total_salary` зависит от значения переменной `age`, которая имеет тип `u8`. В зависимости от значения `age`, переменная `total_salary` может быть либо `u8`, либо `u16`. Однако Zig не может определить тип переменной `total_salary` без явного значения переменной `age`, поэтому он выполняет расширение типа до максимального, который вместит все возможные значения.

## Изменяемость переменных
Как уже упоминалось переменные изменяемы и Вы можете менять значение переменной сколько угодно раз, но при этом вы не можете изменять тип переменной. Следующий код при компиляциии выведет ошибку:

```zig
var x: i32 = 5;
x = 10; // Изменяем значение нашей перемнной
x += 3; // Теперь x равен 13

var y: i32 = 5;
y = 3.14; // Это приведет к ошибке компиляции
```

В языке Zig каждая переменная, которую вы объявляете в своей программе, предполагается изменяемой. Это означает, что вы должны хотя бы один раз изменить её значение в ходе выполнения программы.

Если же переменная остается неизменной, компилятор Zig обнаружит это еще на этапе компиляции и выдаст ошибку. Он предложит вам заменить объявленую переменную на константу (const), поскольку в таком случае её использование будет более корректным. Это помогает писать более чистый и безопасный код, исключая ненужные изменяемые переменные.

Такой подход заставляет разработчика осознанно выбирать между изменяемыми (var) и неизменяемыми (const) значениями, что делает код более предсказуемым и понятным:

```zig
const std = @import("std");

pub fn main() void {
    var y: i32 = 5;

    std.debug.print("Y: {}\n", .{y});
}
```

```
$ zig build
install
└─ install hello
   └─ zig build-exe hello Debug native 1 errors
src/main.zig:6:9: error: local variable is never mutated
    var y: i32 = 5;
        ^
src/main.zig:6:9: note: consider using 'const'
```

Язык программирования Zig обладает строгой системой типов и не выполняет неявное приведение типов. Это означает, что если вам нужно работать с переменными разных типов, вам придется явно указывать их тип или использовать приведение типов вручную.

В Zig нет поддержки литеральных суффиксов как в других языках программирования, таких как C или C++. Вы всегда должны явно указывать тип переменной, либо использовать приведение типов вручную. Но есть поддержка суффиксов для указания размера целочисленных литералов (x, 0, b). Давайте рассмотрим пример:

```zig
const decimal = 42; // Десятичное число
const hex = 0xFF; // Шестнадцатеричное число (255 в десятичной системе)
const octal = 0o77; // Восьмеричное число (63 в десятичной системе)
const binary = 0b1010; // Двоичное число (10 в десятичной системе)
```

## Инициализация переменных
В языке программирования Zig вы не можете использовать переменную без ее инициализации. Прежде чем использовать такую переменную в коде, её необходимо явно инициализировать. Если этого не сделать, компилятор Zig выдаст ошибку во время компиляции, предотвращая возможные проблемы, связанные с использованием неинициализированных данных.

```zig
const std = @import("std");

pub fn main() void {
    var x: i32; // Объявление переменной без инициализации
    std.debug.print("Значение x: {}\n", .{x}); // Попытка использовать неинициализированную переменную
}
```

В результате мы получим ошибку:

```
src/main.zig:4:15: error: expected '=', found ';'
    var x: i32; // Объявление переменной без инициализации
              ^
error: the following command failed with 1 compilation errors:
```

В этом примере переменная `x` объявлена, но ей не присвоено начальное значение. Из-за этого компилятор Zig выдаст ошибку и не позволит скомпилировать программу. Чтобы избежать таких ситуаций, Zig требует явного задания начального значения, так как, если по какой-то причине ваш код использует эту переменную, пока она не инициализирована, у вас будет неопределенное поведение и серьезные ошибки в вашей программе.

## Переменные вычисляемые во время компиляции
Zig предлагает интересную возможность — переменные, которые вычисляются во время компиляции, но при этом могут использоваться в местах, где обычные константы не подходят. Это позволяет выполнять сложные вычисления еще до запуска программы, что может значительно ускорить её выполнение. Давайте рассмотрим пример:

```zig
fn generateFibonacci(comptime n: usize) [n]u64 {
    comptime var fibs: [n]u64 = undefined;
    fibs[0] = 1;
    fibs[1] = 1;

    comptime var i: usize = 2;
    while (i < n) : (i += 1) {
        fibs[i] = fibs[i - 1] + fibs[i - 2];
    }

    return fibs;
}

const fib10 = generateFibonacci(10); // Числа Фибоначчи вычисляются во время компиляции
```

Здесь функция `generateFibonacci` создает массив из n чисел Фибоначчи. Так как аргумент n объявлен как comptime, Zig вычислит значения еще во время компиляции. Переменная `fib10` будет содержать первые 10 чисел Фибоначчи, и во время выполнения программы они уже будут готовы, что избавляет от необходимости рассчитывать их в реальном времени. Более подробно о коде выполняемом на этапе компиляции мы поговорим позднее, а пока просто отметим, что инициализация переменных и констант может быть в виде довольно сложных выражений.

## Константы
В языке Zig константы отличаются от переменных тем, что их значение неизменно и известно еще на этапе компиляции. Это делает код более предсказуемым и безопасным. Для объявления константы используется ключевое слово `const`, а общий синтаксис выглядит следующим образом:

```zig
const имя_константы: тип = значение;
```

Давайте рассмотрим несколько примеров:

```zig
const gravity: f64 = 9.81;
const greeting = "Welcome to Zig!";
```

Если вы попытаетесь изменить значение константы после её объявления, компилятор выдаст ошибку:

```zig
const std = @import("std");

pub fn main() void {
    const gravity: f64 = 9.81;

    gravity = 10.0;
}
```

Выведет:

```
src/main.zig:6:5: error: cannot assign to constant
    gravity = 10.0; // Ошибка! Константы нельзя изменять.
    ^~~~~~~
error: the following command failed with 1 compilation errors:
```

Также как и с переменными при объявлении константы мы можем опустить указание типа, позволив компилятору вывести его за нас:

```zig
const GREETING = "Hello, World!"; // Zig выведет тип как *const [13:0]u8
const MAX_THREADS = 8; // Zig выведет тип как comptime_int
```

Не беспокойтесь, если тип MAX_THREADS (comptime_int) выглядит незнакомым — мы разберем это подробнее позже, когда будем говорить о вычислениях во время компиляции.

Одна из мощных особенностей Zig заключается в том, что все константы вычисляются во время компиляции. Это означает, что вы можете использовать сложные выражения или даже вызовы функций, если они могут быть вычислены во время компиляции. При этом константы вычисляемые на этапе компиляции имеют "ленивую" инициализацию, что означает, что их значение вычисляется только при первом обращении к ним. Давайте рассмотрим пример:

```zig
const BUFFER_SIZE = 1024 * 1024; // 1 MB

fn comptime_sqrt(x: f64) f64 {
    return @sqrt(x);
}

const SQRT_2 = comptime_sqrt(2.0);
```

Здесь константа `SQRT_2` вычисляется с помощью функции `comptime_sqrt`. Так как значение заранее известно, Zig выполнит расчет во время компиляции, и программа просто получит готовый результат.

## Использование переменных и констант
В языке Zig каждая объявленая переменная или константа обязательно должна использоваться в коде. Это означает, что если вы объявите переменную, но нигде её не примените — компилятор выдаст ошибку. Это правило помогает поддерживать чистоту кода и предотвращает накопление неиспользуемых переменных, которые могут запутывать разработчика и делать программу сложнее для понимания.

Если переменная или константа не участвует в выражениях и не передается в функции, компилятор Zig сообщит об этом:

```zig
const std = @import("std");

pub fn main() void {
    const unused_var = 42;
}
```

Выведет:

```
src/main.zig:4:11: error: unused local constant
    const unused_var = 42;
          ^~~~~~~~~~
error: the following command failed with 1 compilation errors:
```

Иногда функции возвращают значения, которые вам не нужны. Например, если функция выполняет какие-то действия, но её возвращаемое значение не имеет для вас значения, вы можете явно “отбросить” его. В Zig для этого используется специальная переменная `_`.

```zig
const age = 15;
_ = age; // Отбрасываем значение
```

Когда переменная присваивается `_`, Zig считает её ненужной и уничтожает. Это позволяет избежать ошибки компиляции, если переменная не будет использоваться далее в коде. После того как вы присвоили значение `_`, использовать переменную снова нельзя. Попытка обратиться к ней приведет к ошибке компиляции

```zig
const age = 15;
_ = age;
// Использование отброшенного значения!
std.debug.print("{d}\n", .{age + 2}); // Ошибка компиляции
```

## Затенение переменных
Во многих языках программирования можно объявить новую переменную с тем же именем, что и у существующей переменной. В этом случае говорят, что первая переменная «затеняется» второй, то есть вторая переменная — это то, что увидит компилятор, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не будет затенена, либо не закончится область видимости.

```zig
const x = 10;
{
    var x = 20; // Это затеняет внешнюю переменную x
    assert(x == 20);
}
assert(x == 10); // Здесь x ссылается на внешнюю переменную
```

В данном примере, во вложенном блоке переменная `x` затеняет переменную `x` из внешнего блока. Это означает, что в блоке `{}` переменная `x` будет иметь значение `20`, а во внешнем блоке переменная `x` будет иметь значение `10`.

В языке Zig затенение переменных запрещено, поэтому приведенный код не скомпилируется. Это может показаться непривычным для тех, кто использует такую возможность в других языках программирования. Однако такое ограничение введено, чтобы избежать ошибок и путаницы в коде. Идеология Zig заключается в упрощении и предсказуемости поведения кода, поэтому затенение переменных здесь не допускается.
