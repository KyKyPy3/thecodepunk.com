---
title: Переменные и константы
date: 2025-02-21 00:11:00
showTableOfContents: true
showComments: true
tags:
  - zig
  - zigbook
---
В языке Zig переменные и константы используются для хранения данных. Zig поддерживает строгую типизацию и требует явной инициализации переменных перед использованием, что предотвращает многие ошибки на этапе компиляции. Это делает код более предсказуемым и безопасным, так как разработчики не могут случайно использовать неинициализированные переменные.

## Объявление переменных
Переменные объявляются с использованием ключевого слова `var`. Их значение можно изменять в течение выполнения программы. По умолчанию для именования переменных в zig принято использовать "змеиную нотацию" (snake_case). В общем виде объявление переменной выглядит так:

```zig
var identifier: type = initial_value;
```

Давайте рассмотрим несколько примеров:

```zig
var age: i32 = 0;
var name: []const u8 = "Алиса";
var is_active: bool = true;
```

В данном примере мы определили три переменных с типами целого числа, строки и булевой переменной, но о типах мы поговорим в следующей главе, а пока давайте остановимся только на определении переменных.

Zig также поддерживает определение нескольких переменных одного типа в одной строке:

```zig
var width: i32 = 10, height: i32 = 20;
```

При объявлении переменной не всегда нужно указывать тип переменной, т.к. zig поддерживает вывод типа, что означает, что вы часто можете опустить явное объявление типа, если предоставлено начальное значение:

```zig
var age = 30; // Zig выведет тип переменной как i32
var pi = 3.14159; // Zig выведет тип переменной как f64
var message = "Привет, мир!"; // Zig выведет тип переменной как []const u8
```

Правда в этом случае, если Вы попытаетесь изменить переменную определенную таким образом, то Zig выдаст ошибку:

```zig
const std = @import("std");

pub fn main() !void {
    var age = 0;

    std.debug.print("Age: {d}, type: {}\n", .{ age, @TypeOf(age) });

    age += 1;
}

# zig build run
run
└─ run vars
   └─ zig build-exe vars Debug native 1 errors
src/main.zig:4:9: error: variable of type 'comptime_int' must be const or comptime
    var age = 0;
        ^~~
src/main.zig:4:9: note: to modify this variable at runtime, it must be given an explicit fixed-size number type
```

В данном случае Zig считает, что наша переменная с неявным типом константа и запрещает ее изменение. Это довольно специфичное поведение для Zig вероятно непривычное для тех кто работает с другими языками программирования. В данном случае Zig придерживается идеи, что намерения разработчика должны быть явно выражены. Считается хорошей практикой явное объявление типов для ясности и предотвращения непреднамеренных преобразований типов. Это особенно важно в больших проектах, где поддержка кода может быть сложной. Но если мы все же хотим сделать наш код рабочим не указываая конкретный тип, то можно добавить префикс `comptime`. Что делает этот префикс, мы поговорим позже, а пока убедимся что наш код работает:

```zig
const std = @import("std");

pub fn main() !void {
    comptime var age = 0;

    std.debug.print("Age: {d}, type: {}\n", .{ age, @TypeOf(age) });

    age += 1;
}
```

```shell
$ zig build run
Age: 0, type: comptime_int
```

## Изменяемость переменных
Как уже упоминалось переменные изменяемы и Вы можете менять значение переменной сколько угодно раз, но при этом вы не можете изменять тип переменной. Следующий код при компиляциии выведет ошибку:

```zig
var x: i32 = 5;
x = 10; // Изменяем значение нашей перемнной
x += 3; // Теперь x равен 13

var y: i32 = 5;
y = 3.14; // Это приведет к ошибке компиляции
```

Каждая переменная, определенная в вашей программе, должна быть изменена. Если этого не произойдет, компилятор обнаружит это на этапе компиляции и предложит заменить переменную на константу:

```zig
var y: i32 = 5;

std.debug.print("Y: {}\n", .{y});

$ zig build
install
└─ install hello
   └─ zig build-exe hello Debug native 1 errors
src/main.zig:6:9: error: local variable is never mutated
    var y: i32 = 5;
        ^
src/main.zig:6:9: note: consider using 'const'
```

Zig строго относится к типам и не выполняет неявное выведение типов. Вы можете использовать литеральные суффиксы, чтобы указать явный тип переменной:

```zig
var a = 10; // i32
var b = 10.0; // f64
var c = 10.0f32; // f32
var d = 10u64; // u64
```

## Инициализация переменных
В Zig вы можете объявить переменные без их инициализации, но вы должны указать тип. Тем не менее, вы должны инициализировать переменную перед ее использованием позднее, иначе вы получите ошибку во время компиляции. Компилятор Zig гарантирует, что все переменные инициализируются перед использованием:

```zig
var uninitialized: i32;
// error: variable 'uninitialized' has no initializer
```

Чтобы избежать таких ситуаций, Zig требует явного задания начального значения, так как, если по какой-то причине ваш код использует эту переменную, пока она не инициализирована, у вас будет неопределенное поведение и серьезные ошибки в вашей программе.

## Переменные вычисляемые во время компиляции
Zig представляет уникальную концепцию - переменные, которые вычисляются во время компиляции, но могут быть использованы так, как константы не могут. Давайте рассмотрим пример:

```zig
fn generateFibonacci(comptime n: usize) [n]u64 {
    @setEvalBranchQuota(10000);
    comptime var fibs: [n]u64 = undefined;
    comptime var i: usize = 0;
    inline while (i < n) : (i += 1) {
        fibs[i] = switch (i) {
            0, 1 => 1,
            else => fibs[i-1] + fibs[i-2],
        };
    }
    return fibs;
}

const fib10 = generateFibonacci(10);
```

Не обращайте внимания на то что код функции нам пока еще не понятен, для нас сейчас это не важно. Важно то, что в данном примере мы определяем константу `fib10`, которая хранит в себе первые 10 чисел Фибоначчи, вычисленные во время компиляции. Иногда такое вычисление может быть полезно, например, для оптимизации кода или для генерации таблицы значений и может довольно сильно ускорить выполнение программы.

## Константы
В отличие от переменных, константы в Zig неизменяемы, и их значение известно на этапе компиляции. Для определения константы необходимо использовать ключевое слово `const`. В общем виде объявление константы выглядит так:

```zig
const identifier: type = value;
```

Давайте рассмотрим несколько примеров:

```zig
const gravity: f64 = 9.81;
const greeting = "Welcome to Zig!";
```

Попытка изменить константу приведёт к ошибке компиляции:

```zig
const gravity: f64 = 9.81;

gravity = 10.0; // Ошибка! Константы нельзя изменять.
```

Также как и с переменными при объявлении константы мы можем опустить указание типа, позволив компилятору вывести его за нас:

```zig
const GREETING = "Hello, World!"; // Zig выведет тип как *const [13:0]u8
const MAX_THREADS = 8; // Zig выведет тип как comptime_int
```

Не обращайте пока на странный тип у MAX_THREADS, мы поговорим об этом в дальнейшем, когда дойдем до выполнения кода во время компиляции.

Одна из мощных особенностей Zig заключается в том, что все константы вычисляются во время компиляции. Это означает, что вы можете использовать сложные выражения или даже вызовы функций, если они могут быть вычисленны во время компиляции. При этом константы вычисляемые на этапе компиляции имеют "ленивую" инициализацию, что означает, что их значение вычисляется только при первом обращении к ним. Давайте рассмотрим пример:

```zig
const BUFFER_SIZE = 1024 * 1024; // 1 MB

fn comptime_sqrt(x: f64) f64 {
    return @sqrt(x);
}

const SQRT_2 = comptime_sqrt(2.0);
```

## Использование переменных и констант
Каждая переменная или константа, которые вы объявляете в Zig, должны каким-то образом использоваться в вашей программе. Вы можете передать их вызову функции в качестве аргумента функции, или вы можете использовать их в каком либо выражении. Если Вы не сделаете это, то компилятор Zig выведет сообщение об ошибке при компиляции вашего кода:

```zig
const unused_var = 42; // Ошибка: переменная не используется
```

Иногда бывает так, что вызываемая вами функция возвращает значение, которое вам не интересно. Чтобы избежать ошибки о неиспользуемой переменной, вы можете использовать специальную переменную с именем `_`, позволяющую отбросить значение:

```zig
const age = 15;
_ = age; // Отбрасываем значение
```

Как только Вы присваиваете переменную символу `_`, вы уничтожаете эту переменную, и при попытке использовать переменную далее в вашем коде Вы получите сообщение об ошибке:

```zig
const age = 15;
_ = age;
// Использование отброшенного значения!
std.debug.print("{d}\n", .{age + 2}); // Ошибка компиляции
```

## Затенение переменных
В Zig можно объявить новую переменную с тем же именем, что и у существующей переменной. В этом случае говорят, что первая переменная «затеняется» второй, то есть вторая переменная — это то, что увидит компилятор, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не будет затенена, либо не закончится область видимости.

```zig
const x = 10;
{
    var x = 20; // Это затеняет внешнюю переменную x
    assert(x == 20);
}
assert(x == 10); // Здесь x ссылается на внешнюю переменную
```

В данном примере, во вложенном блоке переменная `x` затеняет переменную `x` из внешнего блока. Это означает, что в блоке `{}` переменная `x` будет иметь значение `20`, а во внешнем блоке переменная `x` будет иметь значение `10`. Затенение переменных может быть полезным инструментом, но его следует использовать с осторожностью, чтобы избежать путаницы и ошибок в коде. Четкое понимание области видимости и затенения поможет вам писать более чистый и понятный код.
