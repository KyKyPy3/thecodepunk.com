---
title: Кортежи
date: 2025-03-21 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - tuple
---

В прошлой главе мы рассмотрели основное тип используемых структур в Zig - структуры с именованными полями. Одна в Zig довольно часто можно встретить еще два типа структур - структуры в виде кортежей и пустые структуры.

## Кортежи
Кортежи - это структуры, которые содержат только значения, но не имеют именованных полей. В Zig нет встроенного типа “кортеж”, как в Python или Rust, но их можно легко реализовать с помощью анонимных структур. Кортежи довольно часто используются для передачи или возвращения нескольких значений из функций.

Для того чтобы создать кортеж в языке Zig вам нужно создать анонимную структуру, которая содержит только значения. Например:

```zig
const std = @import("std");

pub fn main() !void {
    const tuple: struct { u8, bool } = .{ 42, true };

    std.debug.print("{any} {}\n", .{ tuple, @TypeOf(tuple) });
}
```

Этот код выведет следующее:

```
{ 42, true } struct { u8, bool }
```

Как мы видим из вывода программы тип нашей структуры определяется как `struct { u8, bool }`, т.е. это анонимная структура с двумя полями: первое поле типа `u8` и второе поле типа `bool`.

### Доступ к элементам кортежа
Для доступа к элементам кортежа в Zig есть два способа. Первый и самый простой способ - это использовать оператор `[]`, который мы использовали при работе с массивами или срезами:

```zig
const std = @import("std");

pub fn main() !void {
    const tuple: struct { u8, bool } = .{ 42, true };

    std.debug.print("Number {}\n", .{tuple[0]});
    std.debug.print("Bool {}\n", .{tuple[1]});

    std.debug.print("Tuple len {}\n", .{tuple.len});
}
```

Все поля внутри кортежа доступны по индексам, так же, как в массивах. Кроме того, кортежи в Zig, как и массивы, имеют свойство len, которое возвращает количество элементов. В целом, кортежи можно рассматривать как массивы, в которых элементы могут иметь разные типы.

Второй способ доступа к элементам кортежа - с помощью комбинации операторов `.@`. В этом случае мы обращаемся к элементу кортежа используя не числовое индексирование, а используя имя чилового индекса в кортеже:

```zig
const std = @import("std");

pub fn main() !void {
    const tuple: struct { u8, bool } = .{ 42, true };

    std.debug.print("Number {}\n", .{tuple.@"0"});
    std.debug.print("Bool {}\n", .{tuple.@"1"});
}
```

Конечно второй вариант выглядит менее естественно и обычно все же используют обращение к полям кортежа с помощью числовых индексов.

Для доступа к элементам кортежа мы также можем использовать цикл `inline for` или деструктуризацию кортежа. Использовать обычный цикл `for` с кортежами нельзя, так как для доступа к кортежам используется механизм рефлексии на этапе компиляции:

```zig
const std = @import("std");

pub fn main() !void {
    const tuple: struct { u8, bool } = .{ 42, true };

    inline for (tuple) |item| {
        std.debug.print("Item {}\n", .{item});
    }

    const number, const boolean = tuple;
    std.debug.print("Number {}\n", .{number});
    std.debug.print("Bool {}\n", .{boolean});
}
```

Этот код выведет:

```
Item 42
Item true
Number 42
Bool true
```

Обращение к элементам через деструктуризацию наверно самый популярный способ использование кортежей и чаще всего вы будете встречать именно его в коде.

Если у вас есть указатель на кортеж, то как и в случае массивов вы можете использовать стандартный метод доступа к элементам кортежа через `[]` используя указатель:

```zig
const std = @import("std");

pub fn main() !void {
    const tuple: struct { u8, bool } = .{ 42, true };
    const ptr = &tuple;

    std.debug.print("Number {}\n", .{ptr[0]});
    std.debug.print("Bool {}\n", .{ptr[1]});
}
```

Выведет:

```
Number 42
Bool true
```

## Объединение кортежей
Так как кортежи похожи на массивы мы также как и массивы можем объединять их с помощью оператора `++`:

```zig
const std = @import("std");

pub fn main() !void {
    const tuple1: struct { u8, bool } = .{ 42, true };
    const tuple2: struct { u8, bool } = .{ 24, false };

    const combined = tuple1 ++ tuple2;

    std.debug.print("Combined tuple {any}\n", .{combined});
}
```

Выведет:

```
Combined tuple { 42, true, 24, false }
```

## Пустые структуры
