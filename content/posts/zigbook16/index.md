---
title: Динамические массивы (ArrayList, MultiArrayList)
date: 2025-04-14 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - arraylist
  - multiarraylist
---

Когда мы обсуждали массивы, мы говорили, что это структуры данных, размер которых известен на этапе компиляции и размер является частью их типа. Однако, как вы могли догадаться, довольно часто возникает необходимость в структуре данных, похожей на массив, но с возможностью хранения произвольного количества элементов.

Именно для таких случаев во многих языках программирования существуют массивы переменной длины. Например, в Rust это Vec, в C++ — std::vector, в Go — slice. В языке Zig тоже есть подобная структура, и называется она ArrayList.

ArrayList — одна из самых полезных структур данных, так как её использование требуется во многих практических задачах, где нам надо хранить произвольный список объектов заданного типа. Давайте рассмотрим, как динамические массивы работают в общем виде.

## Динамические массивы
Как мы знаем, для управления обычным массивом данных какого-либо типа языку программирования достаточно трех параметров: адреса начала массива, типа сохраняемого объекта и количество элементов, хранимых в массиве. Однако, если массив имеет переменную длину, то во многих языках к этим параметрам добавляется ещё один — ёмкость (capacity), которая указывает на максимальное количество элементов, которое может храниться в массиве без перераспределения памяти.

Зачем же нужен этот третий параметр и как всё это работает “под капотом”? Давайте разберёмся.

Поскольку такой массив является динамическим, как мы уже знаем, он размещается в куче, а не на стеке. Это связано с тем, что размер динамического массива может изменяться во время выполнения программы, тогда как стек имеет фиксированный объём, заданный на этапе компиляции, и не может быть расширен во время работы программы.

Для хранения элементов массива в куче выделяется непрерывный блок памяти, в который по порядку записываются элементы. Если вдруг выделенного блока памяти становится недостаточно, чтобы вместить все элементы, выделяется новый, более крупный блок. Существующие данные копируются в него, после чего можно продолжать добавление новых элементов — до следующего момента, когда снова понадобится расширение:

{{< figure src="arraylist_dark.svg" class="post-image-dark small">}}
{{< figure src="arraylist_light.svg" class="post-image-light small">}}

Как видно из примера, изначально наш массив содержит всего три элемента, а его ёмкость составляет четыре. Мы начинаем добавлять новые элементы, и как только количество элементов достигнет текущей ёмкости, при попытке добавить следующий элемент произойдёт автоматическое расширение массива — как правило, его размер удваивается. При этом все существующие данные копируются в новое место в памяти.

В целом, по такому принципу работают динамические массивы во многих языках программирования.

Давайте теперь посмотрим как работать с динамическим массивом в языке программирования Zig.

## Создание и инициализация ArrayList
Чтобы создать динамический массив в Zig, сначала необходимо создать аллокатор, который будет использоваться для выделения памяти. Как мы уже знаем, в Zig нет скрытых аллокаций — вся работа с памятью происходит явно через передаваемый вами аллокатор.

Далее, для создания динамического массива нужно передать три параметра - созданный аллокатор, тип элемента, который будет храниться в массиве и начальный размер массива.

```zig
const std = @import("std");

const User = struct {
    id: usize,
    name: []const u8,
};

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = std.ArrayList(User).init(allocator);
    defer list.deinit();

    std.debug.print("Size {d}\n", .{list.items.len});
    std.debug.print("Capacity {d}\n", .{list.capacity});
}
```

Если мы запустим наш код, то получим вывод:

```
Size 0
Capacity 0
```

Как мы видим по умолчанию емкость нашего массива равно 0, т.е. Zig не стал выделять память для нашего массива, пока мы не добавим в него элементы. Как только мы попытаемся добавить элемент в массив, Zig автоматически увеличит емкость массива, причем размер емкости будет выбран на основании типа сохраняемых данных и может быть разным для различных типов. Если мы знеаем сколько элементов максимально будет хранится в нашем массиве, то мы можем задать вручную начальную емкость нашего массива используя метод `initCapacity`:

```zig
const std = @import("std");

const User = struct {
    id: usize,
    name: []const u8,
};

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list1 = std.ArrayList(User).init(allocator);
    defer list1.deinit();

    try list1.append(User{ .id = 1, .name = "Alice" });

    std.debug.print("Size {d}\n", .{list1.items.len});
    std.debug.print("Capacity {d}\n", .{list1.capacity});

    var list2 = std.ArrayList(u8).init(allocator);
    defer list2.deinit();

    try list2.append(1);

    std.debug.print("Size {d}\n", .{list2.items.len});
    std.debug.print("Capacity {d}\n", .{list2.capacity});

    var list3 = try std.ArrayList(u8).initCapacity(allocator, 30);
    defer list3.deinit();

    std.debug.print("Size {d}\n", .{list3.items.len});
    std.debug.print("Capacity {d}\n", .{list3.capacity});
}
```

Если запустить данный код, то мы получим вывод:

```
Size 1
Capacity 5
Size 1
Capacity 128
Size 0
Capacity 30
```

Как можно заметить, при использовании нашей структуры `User` в качестве элемента массива компилятор установил начальную ёмкость массива равной 5. В случае же с типом данных `u8` компилятор определил начальную ёмкость как 128. Из этого можно сделать вывод, что у вас нет гарантий того, что компилятор будет каждый раз выделять одинаковое количество слотов в массиве для разных типов данных. Поскольку операция изменения ёмкости массива довольно затратна, считается хорошей практикой задавать начальное значение ёмкости вручную, чтобы избежать лишних перераспределений памяти и перемещений данных.

## Работа с динамическим массивом
Для добавления значений в массив в Zig предусмотрено несколько методов, таких как `append` и `insert`. Метод `append` добавляет элемент в конец массива и является самым эффективным способом добавления, поскольку работает за константное время — O(1).

Метод `insert`, напротив, позволяет вставить элемент в произвольную позицию внутри массива. Однако такая операция более затратна: при вставке все элементы, находящиеся после указанной позиции, сдвигаются, чтобы освободить место. В худшем случае это может привести к временной сложности O(n), поэтому используйте этот метод только если вам важно сохранять порядок элементов.

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = try std.ArrayList(u8).initCapacity(allocator, 10);
    defer list.deinit();

    try list.append(1);
    try list.append(2);
    try list.append(3);
    try list.append(4);
    try list.append(5);

    // Вставка через insert приведет к сдвигу элементов 3, 4, 5
    try list.insert(2, 10);

    for (list.items) |item| {
        std.debug.print("Element: {}\n", .{item});
    }
}
```

Если нам нужно вставить сразу несколько элементов, например добавить массив из элементов, то вставлять по одному не очень эффективно и можно использовать метод `appendSlice` или `insertSlice`. Первый метод вставит добавляемые элементы в конец массива, а второй вставит элементы в указанное место, а оставшиеся элементы сдвинет на длину вставляемого среза:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = try std.ArrayList(u8).initCapacity(allocator, 10);
    defer list.deinit();

    try list.appendSlice(&[5]u8{ 1, 2, 3, 4, 5 });

    // Вставка через insert приведет к сдвигу элементов 3, 4, 5
    try list.insert(2, 10);

    for (list.items) |item| {
        std.debug.print("Element: {}\n", .{item});
    }
}
```

В данном примере мы заменили множественные вызовы метода `append`, на еденичный вызов метода `appendSlice`, куда передали срез из наших 5 элементов.

Для того, чтобы извлечь элемент из массива у нас есть также два метода - `pop` и `orderedRemove`. Первый метод, симметричен методу `append` - он удаляет последний элемент из нашего массива и возвращает удаленный элемент. Если наш массив пуст, то метод просто вернет null. Второй метод позволяет удалить элемент с конкретной позиции и также симметричен нашему методу `insert`. При использование метода `orderedRemove` он удаляет элемент с указанной позиции, сдвигает все оставшиеся элементы влево и возвращает нам удаленный элемент. Если вам нужно удалять элементы с определенных индексов, но порядок элементов для вас не важен, то используйте метод `swapRemove`. Он рабюотает также эффективно как и `pop` и не требует перемещения элементов в массиве.

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = try std.ArrayList(u8).initCapacity(allocator, 10);
    defer list.deinit();

    try list.appendSlice(&[5]u8{ 1, 2, 3, 4, 5 });

    const elem1 = list.pop();

    if (elem1) |el| {
        std.debug.print("Removed element: {d}\n", .{el});
    }

    for (list.items) |item| {
        std.debug.print("{d} ", .{item});
    }
    std.debug.print("\n", .{});

    const elem2 = list.orderedRemove(2);
    std.debug.print("Removed element: {d}\n", .{elem2});

    for (list.items) |item| {
        std.debug.print("{d} ", .{item});
    }
    std.debug.print("\n", .{});
}
```

Данный код выведет нам:

```
Removed element: 5
1 2 3 4
Removed element: 3
1 2 4
```

Как мы видим использование `orderedRemove` сохранило нам порядок наших элементов, но при этом это и довольно завтратный метод, который может в худшем случае приводить к O(n).

## Использование ArrayList через Writer
Иногда возникает задача получать данные по сети из какого-то источника и сохранять их используя универсальный интерфейс Writer, не задумываясь что за структура данных лежит за нашим интерфейсорм. Для этого у типа ArrayList есть два метода - `writter` и `fixedWriter`. Оба метода возвращают нам интерфейс Writer, отличие второго метода в том, что он вернет интерфейс в котором если при добавлении элемента в массив закончится память, то массив не будет увеличивать свой размер а просто вернет ошибку `error.OutOfMemory`.
