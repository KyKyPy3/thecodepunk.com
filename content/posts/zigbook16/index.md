---
title: Динамические массивы (ArrayList, MultiArrayList)
date: 2025-04-14 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - arraylist
  - multiarraylist
---

Когда мы обсуждали массивы, мы говорили, что это структуры данных, размер которых известен на этапе компиляции и размер является частью их типа. Однако, как вы могли догадаться, довольно часто возникает необходимость в структуре данных, похожей на массив, но с возможностью хранения произвольного количества элементов.

Именно для таких случаев во многих языках программирования существуют массивы переменной длины. Например, в Rust это Vec, в C++ — std::vector, в Go — slice. В языке Zig тоже есть подобная структура, и называется она ArrayList.

Динамические массивы одна из самых полезных структур данных, так как её использование требуется во многих практических задачах, где нам надо хранить произвольный список объектов заданного типа. Давайте рассмотрим, как динамические массивы работают в общем виде.

## Динамические массивы
Как мы знаем, для управления обычным массивом данных произвольного типа языку программирования достаточно трех параметров: адреса начала массива, типа сохраняемого объекта и количество элементов, хранимых в массиве. Однако, если массив имеет переменную длину, то во многих языках к этим параметрам добавляется ещё один — ёмкость (capacity), которая указывает на максимальное количество элементов, которое может храниться в массиве без перераспределения памяти.

Зачем же нужен этот третий параметр и как всё это работает “под капотом”? И что за перераспределение памяти? Давайте разберёмся.

Поскольку наш массив является динамическим, как мы уже знаем, он размещается в куче, а не на стеке. Это связано с тем, что размер динамического массива может изменяться во время выполнения программы, тогда как стек имеет фиксированный объём, заданный на этапе компиляции, и не может быть расширен во время работы программы.

Для хранения элементов массива в куче выделяется непрерывный блок памяти, в который по порядку записываются элементы. Если вдруг выделенного блока памяти становится недостаточно, чтобы вместить все элементы, выделяется новый, более крупный блок. Существующие данные копируются в этот новый сегмент памяти, после чего старый сегмент освобождается и можно продолжать добавление новых элементов — до следующего момента, когда снова понадобится расширение сегмента памяти:

{{< figure src="arraylist_dark.svg" class="post-image-dark small">}}
{{< figure src="arraylist_light.svg" class="post-image-light small">}}

Как видно из примера, изначально наш массив содержит всего три элемента, а его ёмкость составляет четыре. Мы начинаем добавлять новые элементы, и как только количество элементов достигнет текущей ёмкости, при попытке добавить следующий элемент произойдёт автоматическое расширение массива — как правило, его размер удваивается. При этом все существующие данные копируются в новое место в памяти. В целом, по такому принципу работают динамические массивы во многих языках программирования.

Давайте теперь посмотрим как работать с динамическим массивом в языке программирования Zig.

## Создание и инициализация ArrayList
Чтобы создать динамический массив в Zig, сначала необходимо создать аллокатор, который будет использоваться для выделения памяти. Как мы уже знаем, в Zig нет скрытых аллокаций — вся работа с памятью происходит явно через передаваемый вами аллокатор.

Далее, для создания динамического массива нужно передать три параметра - созданный аллокатор, тип элемента, который будет храниться в массиве и начальный размер массива.

```zig
const std = @import("std");

const User = struct {
    id: usize,
    name: []const u8,
};

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = std.ArrayList(User).init(allocator);
    defer list.deinit();

    std.debug.print("Size {d}\n", .{list.items.len});
    std.debug.print("Capacity {d}\n", .{list.capacity});
}
```

Если мы запустим наш код, то получим вывод:

```
Size 0
Capacity 0
```

Как мы видим по умолчанию емкость нашего массива равно 0, т.е. Zig не стал выделять память для нашего массива, пока мы не добавим в него элементы. Как только мы попытаемся добавить элемент в массив, Zig автоматически увеличит емкость массива, причем размер емкости будет выбран на основании типа сохраняемых данных и может быть разным для различных типов. Если мы знаем сколько элементов максимально будет хранится в нашем массиве, то мы можем задать вручную начальную емкость нашего массива используя метод `initCapacity`:

```zig
const std = @import("std");

const User = struct {
    id: usize,
    name: []const u8,
};

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list1 = std.ArrayList(User).init(allocator);
    defer list1.deinit();

    try list1.append(User{ .id = 1, .name = "Alice" });

    std.debug.print("Size {d}\n", .{list1.items.len});
    std.debug.print("Capacity {d}\n", .{list1.capacity});

    var list2 = std.ArrayList(u8).init(allocator);
    defer list2.deinit();

    try list2.append(1);

    std.debug.print("Size {d}\n", .{list2.items.len});
    std.debug.print("Capacity {d}\n", .{list2.capacity});

    var list3 = try std.ArrayList(u8).initCapacity(allocator, 30);
    defer list3.deinit();

    std.debug.print("Size {d}\n", .{list3.items.len});
    std.debug.print("Capacity {d}\n", .{list3.capacity});
}
```

Если запустить данный код, то мы получим вывод:

```
Size 1
Capacity 5
Size 1
Capacity 128
Size 0
Capacity 30
```

Как можно заметить, при использовании нашей структуры `User` в качестве элемента массива компилятор установил начальную ёмкость массива равной 5. В случае же с типом данных `u8` компилятор определил начальную ёмкость как 128. Из этого можно сделать вывод, что у вас нет гарантий того, что компилятор будет каждый раз выделять одинаковое количество слотов в массиве для разных типов данных. Поскольку операция изменения ёмкости массива довольно затратна, считается хорошей практикой задавать начальное значение ёмкости вручную, чтобы избежать лишних перераспределений памяти и перемещений данных.

## Работа с динамическим массивом
Для добавления значений в массив в Zig предусмотрено несколько методов, таких как `append` и `insert`. Метод `append` добавляет элемент в конец массива и является самым эффективным способом добавления, поскольку работает за константное время — O(1).

Метод `insert`, напротив, позволяет вставить элемент в произвольную позицию внутри массива. Однако такая операция более затратна: при вставке все элементы, находящиеся после указанной позиции, сдвигаются, чтобы освободить место. В худшем случае это может привести к временной сложности O(n), поэтому используйте этот метод только если вам важно сохранять порядок элементов.

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = try std.ArrayList(u8).initCapacity(allocator, 10);
    defer list.deinit();

    try list.append(1);
    try list.append(2);
    try list.append(3);
    try list.append(4);
    try list.append(5);

    // Вставка через insert приведет к сдвигу элементов 3, 4, 5
    try list.insert(2, 10);

    for (list.items) |item| {
        std.debug.print("Element: {}\n", .{item});
    }
}
```

Если нам нужно вставить сразу несколько элементов, например добавить массив из элементов, то вставлять по одному не очень эффективно и можно использовать метод `appendSlice` или `insertSlice`. Первый метод вставит добавляемые элементы в конец массива, а второй вставит элементы в указанное место, а оставшиеся элементы сдвинет на длину вставляемого среза:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = try std.ArrayList(u8).initCapacity(allocator, 10);
    defer list.deinit();

    try list.appendSlice(&[5]u8{ 1, 2, 3, 4, 5 });

    // Вставка через insert приведет к сдвигу элементов 3, 4, 5
    try list.insert(2, 10);

    for (list.items) |item| {
        std.debug.print("Element: {}\n", .{item});
    }
}
```

В данном примере мы заменили множественные вызовы метода `append`, на еденичный вызов метода `appendSlice`, куда передали срез из наших 5 элементов.

## Удаление элементов из массива

Для того, чтобы извлечь элемент из массива у нас есть также два метода - `pop` и `orderedRemove`. Первый метод, симметричен методу `append` - он удаляет последний элемент из нашего массива и возвращает удаленный элемент. Если наш массив пуст, то метод `pop` просто вернет null. Второй метод `orderedRemove` позволяет удалить элемент с конкретной позиции и также симметричен нашему методу `insert`. При использование метода `orderedRemove` он удаляет элемент с указанной позиции, сдвигает все оставшиеся элементы влево и возвращает нам удаленный элемент. Если вам нужно удалять элементы с определенных индексов, но порядок элементов для вас не важен, то используйте метод `swapRemove`. Он работает также эффективно как и `pop` и не требует перемещения элементов в массиве как метод `orderedRemove`. Однако у него есть один важный момент - внутри этот метод при удалении элемента перемещает на его позицию последний элемент массива, что явным образом нарушает порядок.

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = try std.ArrayList(u8).initCapacity(allocator, 10);
    defer list.deinit();

    try list.appendSlice(&[5]u8{ 1, 2, 3, 4, 5 });

    const elem1 = list.pop();

    if (elem1) |el| {
        std.debug.print("Removed element: {d}\n", .{el});
    }

    for (list.items) |item| {
        std.debug.print("{d} ", .{item});
    }
    std.debug.print("\n", .{});

    const elem2 = list.orderedRemove(2);
    std.debug.print("Removed element: {d}\n", .{elem2});

    for (list.items) |item| {
        std.debug.print("{d} ", .{item});
    }
    std.debug.print("\n", .{});

    try list.append(10);
    try list.append(20);
    std.debug.print("До swapRemove: ", .{});
    for (list.items) |item| {
        std.debug.print("{d} ", .{item});
    }
    std.debug.print("\n", .{});

    const elem3 = list.swapRemove(1);
    std.debug.print("Removed element: {d}\n", .{elem3});

    std.debug.print("После swapRemove: ", .{});
    for (list.items) |item| {
        std.debug.print("{d} ", .{item});
    }
    std.debug.print("\n", .{});
}
```

Данный код выведет нам:

```
Removed element: 5
1 2 3 4
Removed element: 3
1 2 4
До swapRemove: 1 2 4 10 20
Removed element: 2
После swapRemove: 1 20 4 10
```

Как мы видим использование `orderedRemove` сохранило нам порядок наших элементов, но при этом это и довольно завтратный метод, который может в худшем случае приводить к O(n). А вот `swapRemove` нарушает порядок, перемещая последний элемент на место удаляемого, но работает за O(1).

### Очистка массива

Если вам нужно удалить все элементы из массива, есть два основных метода:

```zig
// Очищает содержимое, не освобождая память
list.clearRetainingCapacity();

// Очищает содержимое и освобождает память
list.clearAndFree();
```

Метод `clearRetainingCapacity` просто сбрасывает размер до нуля, но сохраняет выделенную память. Это полезно, если вы планируете повторно использовать массив для хранения новых данных.

Метод `clearAndFree` полностью освобождает выделенную память. Используйте его, когда вам нужно минимизировать использование памяти.

## Использование ArrayList через Writer
Иногда возникает задача получать данные по сети из какого-либо источника и сохранять их, используя универсальный интерфейс `Writer`, не задумываясь о том, какая именно структура данных стоит за этим интерфейсом. Для этого у типа `ArrayList` есть два метода: `writer` и `fixedWriter`. Оба возвращают интерфейс `Writer`, но между ними есть важное различие.

Метод `writer` возвращает `Writer`, который при необходимости автоматически увеличивает размер массива. Метод `fixedWriter`, напротив, возвращает `Writer`, который не расширяет массив при нехватке памяти — вместо этого он вернёт ошибку `error.OutOfMemory`.

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = std.ArrayList(u8).init(allocator);
    defer list.deinit();

    var wrt = list.writer();

    try wrt.print("Hello world", .{});

    for (list.items) |item| {
        std.debug.print("{c}", .{item});
    }
    std.debug.print("\n", .{});

    // Пример использования fixedWriter
    var fixed_list = try std.ArrayList(u8).initCapacity(allocator, 5);
    defer fixed_list.deinit();

    var fixed_wrt = fixed_list.fixedWriter();

    // Это успешно запишет 5 байт
    try fixed_wrt.writeAll("Hello");

    // Это вернет ошибку OutOfMemory, так как ёмкость массива ограничена 5 байтами
    fixed_wrt.writeAll(" world") catch |err| {
        std.debug.print("Ошибка при записи: {s}\n", .{@errorName(err)});
    };

    std.debug.print("Fixed list content: ", .{});
    for (fixed_list.items) |item| {
        std.debug.print("{c}", .{item});
    }
    std.debug.print("\n", .{});
}
```

В данном примере мы получаем из нашего списка интерфейс `Writer` и дальше используем методы интерфейса чтобы писать наши данные в наш динамический массив.

## Внутреннее устройство ArrayList
Как вы, возможно, уже заметили, структура `ArrayList` по сути является обёрткой над обычным массивом, дополненной логикой для управления выделением и освобождением памяти.

Когда нам нужно получить доступ к элементам, хранящимся в `ArrayList`, мы можем напрямую обращаться к его полю `items` — это и есть внутренний массив. Через него можно итерироваться по данным или изменять их. Однако важно помнить: получать ссылки (указатели) на элементы этого массива может быть небезопасно. Если произойдёт перераспределение памяти (например, при увеличении ёмкости), массив будет перемещён, и все ранее полученные указатели станут невалидными.

Иногда бывает удобно не просто получить доступ к внутреннему массиву, но и полностью “отцепить” его от `ArrayList`. Это может понадобиться, например, если вы накопили нужное количество данных и хотите передать их дальше, сбросив состояние `ArrayList`.

Для таких случаев у структуры есть метод `toOwnedSlice`. Он возвращает срез с текущими данными, а внутри `ArrayList` создаёт новый пустой массив. Таким образом, происходит передача владения данными вызывающему коду, и теперь именно он отвечает за освобождение памяти, занятой этим срезом.

```zig
const std = @import("std");

fn to_upper(allocator: std.mem.Allocator, reader: anytype) ![]u8 {
    var list = std.ArrayList(u8).init(allocator);
    defer list.deinit();

    while (true) {
        const byte = reader.readByte() catch |err| {
            if (err == error.EndOfStream) break;
            return err;
        };

        const uppercased = if (byte >= 'a' and byte <= 'z')
            byte - ('a' - 'A')
        else
            byte;

        try list.append(uppercased);
    }

    // Передаем владение данными вызывающему коду
    // После этого вызова list становится пустым (и deinit не освободит память)
    return list.toOwnedSlice();
}

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const data = "Hello Zig!";
    var stream = std.io.fixedBufferStream(data);

    const upper = try to_upper(allocator, stream.reader());
    defer allocator.free(upper);

    std.debug.print("Result: {s}\n", .{upper});
}
```

В этом примере мы реализовали функцию, которая принимает на вход поток, читает из него символы, переводит их в верхний регистр и сохраняет в `ArrayList`. После того как все данные считаны, мы возвращаем срез, передавая владение этими данными вызывающему коду.

Такой подход особенно полезен, когда нужно сформировать данные в одной функции, а затем передать их в другую или вернуть без лишнего копирования. Метод `toOwnedSlice()` позволяет эффективно передавать владение, избавляя от необходимости копировать данные и упрощая управление памятью.
