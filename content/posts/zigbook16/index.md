---
title: Динамические массивы (ArrayList, MultiArrayList)
date: 2025-04-14 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - arraylist
  - multiarraylist
---

Когда мы обсуждали массивы, мы говорили, что это структуры данных, размер которых известен на этапе компиляции и является частью их типа. Однако, как вы могли догадаться, довольно часто возникает необходимость в структуре данных, похожей на массив, но с возможностью изменять размер хранимых данных.

Именно для таких случаев во многих языках программирования существуют массивы переменной длины. Например, в Rust это Vec, в C++ — std::vector, в Go — slice. В языке Zig тоже есть подобная структура, и называется она ArrayList.

ArrayList — одна из самых полезных структур данных, так как её использование требуется во многих практических задачах. Давайте рассмотрим, как она работает.

## Динамические массивы
Как мы знаем, для управления обычным массивом данных какого-либо типа языку программирования достаточно двух параметров: адреса начала массива и его размера. Однако если массив имеет переменную длину, то во многих языках к этим данным добавляется ещё один параметр — ёмкость (capacity), которая указывает на максимальное количество элементов, которое может храниться в массиве без перераспределения памяти.

Зачем же нужен этот третий параметр и как всё это работает “под капотом”? Давайте разберёмся.

Поскольку такой массив является динамическим, как мы уже знаем, он размещается в куче, а не на стеке. Это связано с тем, что размер динамического массива может изменяться во время выполнения программы, тогда как стек имеет фиксированный объём, заданный на этапе компиляции, и не может быть расширен в процессе выполнения.

Теперь давайте посмотрим, как такой массив размещается в куче.

{{< figure src="arraylist_dark.svg" class="post-image-dark small">}}
{{< figure src="arraylist_light.svg" class="post-image-light small">}}

Как видно из примера, изначально наш массив содержит всего три элемента, а его ёмкость составляет четыре. Мы начинаем добавлять новые элементы, и как только количество элементов достигнет текущей ёмкости, при попытке добавить следующий элемент произойдёт автоматическое расширение массива — как правило, его размер удваивается. При этом все существующие данные копируются в новое место в памяти.

В целом, по такому принципу работают динамические массивы во многих языках программирования.

Давайте теперь посмотрим как работать с динамическим массивом в языке программирования Zig.

## Создание и инициализация ArrayList
Чтобы создать динамический массив в Zig, сначала необходимо создать аллокатор, который будет использоваться для выделения памяти. Как мы уже знаем, в Zig нет скрытых аллокаций — вся работа с памятью происходит явно через передаваемый вами аллокатор.

Далее, для создания динамического массива нужно передать три параметра - созданный аллокатор, тип элемента, который будет храниться в массиве и начальный размер массива.

```zig
const std = @import("std");

const User = struct {
    id: usize,
    name: []const u8,
};

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list = std.ArrayList(User).init(allocator);
    defer list.deinit();

    std.debug.print("Size {d}\n", .{list.items.len});
    std.debug.print("Capacity {d}\n", .{list.capacity});
}
```

Если мы запустим наш код, то получим вывод:

```
Size 0
Capacity 0
```

Как мы видим по умолчанию емкость нашего массива равно 0, т.е. Zig не стал выделять память для нашего массива, пока мы не добавим в него элементы. Как только мы попытаемся добавить элемент в массив, Zig автоматически увеличит емкость массива, причем размер емкости будет выбран на основании типа сохраняемых данных и может быть разным для пазличных типов. также мы можем задать вручную начальную емкость нашего массива используя метод `initCapacity`:

```zig
const std = @import("std");

const User = struct {
    id: usize,
    name: []const u8,
};

pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}).init;
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var list1 = std.ArrayList(User).init(allocator);
    defer list1.deinit();

    try list1.append(User{ .id = 1, .name = "Alice" });

    std.debug.print("Size {d}\n", .{list1.items.len});
    std.debug.print("Capacity {d}\n", .{list1.capacity});

    var list2 = std.ArrayList(u8).init(allocator);
    defer list2.deinit();

    try list2.append(1);

    std.debug.print("Size {d}\n", .{list2.items.len});
    std.debug.print("Capacity {d}\n", .{list2.capacity});

    var list3 = try std.ArrayList(u8).initCapacity(allocator, 30);
    defer list3.deinit();

    std.debug.print("Size {d}\n", .{list3.items.len});
    std.debug.print("Capacity {d}\n", .{list3.capacity});
}
```

Если запустить данный код, то мы получим вывод:

```
Size 1
Capacity 5
Size 1
Capacity 128
Size 0
Capacity 30
```

Как можно заметить, при использовании нашей структуры `User` в качестве элемента массива компилятор установил начальную ёмкость массива равной 5. В случае же с типом данных `u8` компилятор определил начальную ёмкость как 128.
