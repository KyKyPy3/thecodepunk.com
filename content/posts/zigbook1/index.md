---
title: Введение в ZIG
date: 2025-02-20 00:11:00
showTableOfContents: true
showComments: true
tags:
  - zig
  - go
  - zigbook
---
Это вводная глава по языку Zig. В ней мы рассмотрим, что такое язык Zig, чем он уникален, и сравним его немного с другими языками. Также мы настроим среду для сборки Zig-приложений, немного взглянем на процесс сборки и соберем простую программу.

## Появление Zig
Zig — это системный язык программирования. Он начал свою историю в 2015 году, когда его автор, Эндрю Келли, согласно легенде, хотел написать хороший музыкальный плеер. Попробовав написать его на Node.js, Rust и C++, он в конечном итоге пришел к разработке собственного языка. Андрю хотел писать код на C, поняв, что так он сможет полностью реализовать все задуманное, но его отталкивала архаичность C и проблемы с безопасностью, присущие языку C. Долгое время язык оставался в тени, и, вероятно, только в 2024 году у него начался резкий скачок популярности. Это произошло отчасти потому, что язык набрал "критическую" массу, а также потому, что некоторые компании стали использовать его в production, тем самым дав программистам понять, что язык заслуживает интереса.

Итак, что же такое Zig и зачем нам еще один язык, когда у нас уже есть C, C++, Java и Go? К сожалению, многие языки, такие как C++ и Java, за годы своего существования стали очень сложными. Порог входа в них стал довольно высоким, а высококлассных специалистов, знающих тонкости языка, на рынке меньше, чем нужно, что создало дефицит разработчиков. Научить довольно большое число людей хорошо знать язык — сложная задача, поэтому многие пытались решать ее другими путями. Например, компания Google создала Go — очень простой язык, разработанный под решение конкретных задач, которые часто возникали в компании, а разработчиков не хватало. Некоторые сообщества решали проблему схожим образом, так, например, появился Rust или Cobalt, которые стремились исправить проблемы C++, или Kotlin, который должен был исправить проблемы Java. Но создать язык, который был бы простым, выразительным и при этом решал бы все возможные задачи — сложная задача. Попытка сделать язык универсальным привела к тому, что люди устали от C++ и Java. Чтобы сделать язык понятным и удобным, Вам придется чем-то пожертвовать, и Zig тут не исключение. В этом языке многие вещи были исключены, так как он разрабатывался для решения конкретных задач. Хотя многие считают, что его можно использовать и для широкого круга задач.

## Философия Zig
Давайте рассмотрим, что же было заложено в философию Zig его автором и поддерживается теперь сообществом:

### Простота
Автор языка Zig старался сделать его простым и не добавлять в него сложных конструкций, которые бы усложняли чтение кода. Например, долгое время в Zig не было цикла for — считалось, что цикла while вполне достаточно для выполнения любых задач. В Zig нет скрытого потока управления, макросов и препроцессора. Zig гарантирует, что поток выполнения является явным и прозрачным. В отличие от C++, Zig не поддерживает перегрузку операторов, неявные преобразования или исключения, которые могут вызывать скрытые переходы в потоке управления. Этот принцип проектирования улучшает читаемость, предсказуемость и простоту отладки. "Код, который ты видишь, ты и получаешь" — именно такой мыслью вдохновлялся автор языка. Да, в Zig есть дополнительный режим выполнения кода — который выполняется во время компиляции, но это довольно простой инструмент, в отличие от макросов в Rust, например. Когда вы стараетесь сделать простой язык программирования, у вас есть два пути: либо вы просто исключаете возможности из языка, либо переносите всю сложность в рантайм языка. Второй путь выбрал Google при создании Go, в Zig же автор пошел по первому пути, просто исключив многое из языка, так как создание сложного рантайма нарушало бы другие принципы языка. Иногда, наткнувшись на отсутствие чего-то привычного, вы впадаете в ступор и зависаете с вопросом «а как?», например, не найдя в языке привычного механизма интерфейсов. Конечно, это потребует от разработчика перезагрузить свой «ментальный генератор» кода и настроить его под язык. В целом авторы языка придерживаются идеи, что для каждой задачи должен быть только один очевидный способ решения. Я согласен с таким подходом, а также с тем, что язык должен загружаться в голову разработчика за пару дней и удерживаться там минимальными усилиями. Удачное это решение и сможет ли сообщество языка держать тот же курс в простоте — покажет время, но в целом этот принцип довольно хорош и показал свою эффективность при появлении языка Go.

### Надежность
Проектируя язык, автор и сообщество стараются не забывать о том, что в наше время язык должен быть надежным, но делают это немного по-своему. Например, если Rust просто не дает разработчику вляпаться в «простые» баги, которые легко не заметить, если у вас большая кодовая база, то Zig встраивает надежность только если это не противоречит остальным принципам языка, таким как «Простота» и «Оптимальность». Язык Zig нельзя назвать 100% надежным, так как такая задача и не стоит перед разработчиками языка. Вы легко можете поймать здесь ошибки утечки памяти или висящих указателей, если вы не очень опытный программист и не думаете о «детских» проблемах кода, когда его пишете. Тем не менее, от некоторых ошибок язык все же старается либо защитить, либо дать вам инструмент, который позволит сократить вероятность появления таких ошибок. Например, Zig дает вам проверку выхода за границы массива, чтобы избежать таких ошибок, предлагает интересный подход с аллокаторами и defer, позволяя упростить работу с выделением и освобождением памяти. В Zig также есть тестовые аллокаторы, позволяющие отлавливать утечки памяти. В целом язык точно не оставит вас один на один с «детскими» проблемами, но и усложнять написание кода в угоду безопасности тоже не станет. В Zig также подумали об обработке ошибок и, вдохновившись наверно такими языками как Go или Rust, сделали обработку ошибок без генерации исключений. В Zig обработка ошибок очень похожа на Rust с одним отличием — она упрощена. Если вы хотите правильно обрабатывать ошибки на Rust и введёте это в поисковый запрос в Google, вы найдете множество статей о том, как "правильно" обрабатывать ошибки с использованием сторонних пакетов. В Zig, из-за простоты языка, вам потребуется совсем немного времени, чтобы разобраться, как обрабатывать ошибки в вашей программе.

### Производительность
Язык Zig — это системный язык программирования, и он предлагает вам писать код довольно близко к железу и ОС. Если вам важна производительность вашего кода, то вам нужно точно контролировать то, что получится на выходе процесса компиляции и превратится в машинный код. Также вам нужно полностью управлять потоком выполнения вашей программы, исключив влияние рантайма или других скрытых эффектов выбранного языка. Zig проектировался с учетом того, что в нем нет скрытых вещей, которые были бы не прозрачны для разработчика и приводили бы к не оптимальному коду на выходе компиляции. Zig поддерживает как связывание с libc, так и не связывание с ней, что делает его удобным для разработки на голом железе и высокопроизводительной разработки. В этом плане Zig очень похож на язык C, и не редко можно услышать, что Zig называют «C на стероидах». В целом, если производительность и предсказуемость вашего кода вам важны, то в Zig есть все и даже больше для того, чтобы писать очень производительный код.

### Оптимальность
Оптимальность подразумевает написание кода, который наилучшим образом использует ресурсы, такие как ЦП и память. Язык Zig старается дать разработчику инструменты, которые позволяют писать наиболее оптимальный код. У вас есть полный контроль над вашим кодом — никаких скрытых затрат, никаких «закулисных» обработок кода. Язык старается не приносить никаких решений только потому, что это есть где-то еще. Например, добавление асинхронного кода в Zig было приостановлено, и автор сказал, что сейчас поддержки async в языке не будет, так как нет понимания, как сделать это, не нарушая другие принципы языка. А добавлять ее только потому, что она есть в других языках — полнейший бред. Противники асинхронного кода наверняка в восторге от такого решения. Возможно, когда-то в будущем поддержка асинхронности и появится, но это точно будет не в первой версии языка.

### Читаемость
Многим разработчикам давно известно, что мы читаем код гораздо больше времени, чем пишем. И чем проще процесс чтения делает нам язык программирования, тем легче нам поддерживать кодовую базу. Есть довольно большое количество языков, где можно написать очень эстетичный и компактный код, но по прошествии времени вы потратите много усилий, пытаясь понять его и вспомнить, что же он делает. Разработчики языка Zig старались сделать идиоматику языка такой, чтобы, читая код на Zig, вы тратили время на разбирательство логики вашей программы, а не на воспоминание конструкций языка или хитрых «паттернов» кода. Например, иногда из-за контроля со стороны Rust вашего кода вам приходится усложнять его, чтобы «побороть» компилятор, хотя в этом нет никакой необходимости, ведь с точки зрения бизнес-логики ваш код работает только по одному «пути», и другие просто невозможны, но попробуйте убедить в этом Rust.

## Уникальные возможности zig
### Полная совместимость с C
Язык Zig поддерживает полную совместимость с C, что позволяет вам включать код на C в вашу Zig-программу, и это все скомпилируется без головной боли. Это довольно важное преимущество, так как когда появляется новый язык и в нем еще нет широкого набора написанных готовых библиотек, любой, кто пытается написать что-то, сталкивается с тем, что те вещи, которые давно уже легко добавлялись в других языках парой команд, в Zig надо написать с нуля, да еще и кроссплатформенно. Имея доступ к огромной кодовой базе языка C, вы немного облегчаете себе эту проблему, просто переиспользуя куски кода, написанные для C и проверенные годами их использования.

### Выполнение кода во время компиляции (Comptime)
Выполнение кода во время компиляции в Zig конечно не новое изобретение, но очень мощное. Вычисления во время компиляции впервые появились еще в Lisp в 60-х годах. Тем не менее, эту особенность языка обычно не встретишь в статических языках программирования. Что-то похожее можно увидеть в C++, но там это, мне кажется, получилось не совсем удачно (речь идет о шаблонах). Возможность выполнения кода во время компиляции позволяет разработчикам писать универсальный код, а также приносит возможности метапрограммирования без внедрения шаблонов, как это сделано в C++. Давайте рассмотрим пример, чтобы понять, что такое comptime в языке Zig. Предположим, что у нас есть функция вычисления максимума двух чисел:

```zig
fn maximum(a: i32, b: i32) i32 {
    var result: i32 = undefined;

    if (a > b) {
        result = a;
    } else {
        result = b;
    }

    return result;
}
```

Очевидно, что данное решение ограничено и поддерживает только 32-битные числа. Если бы мы писали на C, нам пришлось бы использовать макросы препроцессора, чтобы сделать код универсальным, но создатели языка не хотели наследовать эту не самую удачную часть C.

Во многих языках, поддерживающих generic-код, вы решите эту проблему довольно просто, и Zig дает вам с одной стороны похожее решение, с другой — гораздо более гибкое, так как выполнение кода во время компиляции можно использовать не только для шаблонного кода, но и для множества других задач. При этом вам не придется изучать новые особенности языка — вы используете один инструмент для решения нескольких задач. Давайте рассмотрим решение этой проблемы на Zig:

```zig
fn maximum(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}
```
Здесь мы говорим компилятору, что тип нашей переменной будет известен во время компиляции, и компилятор просто сгенерирует нужный набор функций для различных типов. Это примерно похоже на то, как делает Rust, который тоже по вашему шаблонному коду сгенерирует функции под разные типы данных, но, как я уже сказал, в Zig вы можете использовать этот подход и для решения других задач. Например, в нашей функции сейчас нет проверки, что в нее передали только те типы данных, которые поддерживают сравнения. Давайте добавим это в наш код:

```zig
fn assertNumber(comptime T: type) void {
    const is_num = switch (T) {
        i8, i16, i32, i64 => true,
        u8, u16, u32, u64 => true,
        comptime_int, comptime_float => true,
        f16, f32, f64 => true,
        else => false,
    };

    if (!is_num) {
        @compileError("Inputs must be numbers");
    }
}

fn maximum(comptime T: type, a: T, b: T) T {
    const A = @TypeOf(a);
    const B = @TypeOf(b);

    assertNumber(A);
    assertNumber(B);

    if (A != B) {
        @compileError("Inputs must be of the same type");
    }

    return if (a > b) a else b;
}
```

Выполнение кода во время компиляции — довольно простой и мощный механизм, но у него, конечно, есть ограничения. Например, вы не можете взаимодействовать с пользовательским вводом, читать из файла или выполнять сетевые запросы. Но в целом текущих возможностей достаточно для решения многих задач, которые в других языках либо выглядят сложнее, например, как макросы в Rust, либо немного странно встроены в язык, как это сделано в Go с generate.

### Кросс-компиляция
В наше время мы имеем разнообразие операционных систем, и когда мы хотим выпустить наш продукт в жизнь, мы хотим, чтобы он работал сразу на всех возможных ОС. К сожалению, кросс-компиляция кода не всегда работает удачно в языках, и нередко нужно потратить много времени и нервов, чтобы получить необходимый результат. Например, те, кто пытался скомпилировать код под три основных платформы на Rust, знают, что это не так просто. И даже если ваш код скомпилировался, не факт, что он заработает, так как вы скомпилировали его с GLIBC, установленной на вашей машине, а на целевой машине версия GLIBC может быть более древней, и код просто не будет работать. В Zig же кросс-компиляция работает из коробки, и более того, вы можете указать версию GLIBC, с которой нужно слинковать ваш код, даже не имея ее установленной на вашей машине. Это сильно упрощает процесс сборки вашей программы на одной машине и соответствует принципу Zig: «Сосредоточьтесь на отладке своего приложения, а не на проверке своих знаний о языке программирования».

### Никаких скрытых выделений памяти
Zig использует подход невмешательства при выделении кучи, то есть никакие языковые возможности неявно не выделяют память в куче. В отличие от C++ и других языков, где определенные операции (например, конкатенация строк или вызовы сопрограмм) могут вызывать скрытые выделения кучи, Zig требует, чтобы все выделения кучи были явными. Такая конструкция гарантирует разработчикам полный контроль над управлением памятью, что улучшает предсказуемость и делает код подходящим для сред, где выделения кучи нежелательны. Конечно, это накладывает на разработчика определенные требования, чтобы он понимал, как работает выделение памяти в программах, а не просто надеялся, что GC приберет за ним все и очистит память. Для этого Zig дает нам несколько различных типов аллокаторов памяти под разные задачи, а также упрощает работу с ними, предоставив конструкции defer и errdefer.

## Области применения
Zig не разрабатывался как универсальный язык, и есть области, где использование Zig подойдет наилучшим образом:

- **Системное программирование**: разработка операционных систем, драйверов устройств и низкоуровневых системных утилит.
- **Разработка игр**: создание игровых движков, графических инструментов и игр.
- **Веб-разработка**: компиляция кода Zig в Web Assembly для запуска высокопроизводительных приложений в браузере.
- **Встроенные системы**: программирование микроконтроллеров и разработка устройств Интернета вещей.
- **Инструменты и утилиты**: создание эффективных инструментов и утилит командной строки.
- **Научные вычисления**: написание числовых библиотек и моделирования.
- **Сеть**: внедрение сетевых протоколов и высокопроизводительных серверов.
- **Обработка данных**: разработка инструментов анализа данных и расширений баз данных.

Если вы разрабатываете продукт в одной из этих областей Вам точно стоит присмотреться к zig.

## Установка
Давайте наконец установим Zig на машину. Установка Zig довольно проста — вам просто нужно скачать версию Zig с сайта https://ziglang.org/ для вашей ОС, распаковать архив в папку, и все. Добавив папку из распакованного архива в вашу переменную PATH вы сможете использовать все возможности Zig. Для того чтобы проверить что все установилось как надо выполните комаду `zig version`:

```shell
$ zig version
0.13.0
```

Если Вы используете VS Code в качестве IDE для разработки, то для работы с Zig Вам надо установить два расширения - Zig Language и CodeLLDB. Первое даст Вам правильную работу с кодом на Zig, а второе позволит отлаживать код.

## Компиляция тестового кода
Итак, давайте напишем первый код. Для этого создайте директорию, перейдите в нее и выполните команду `zig init`:

```shell
$ mkdir simple
$ cd simple
$ zig init

info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig
info: see `zig build --help` for a menu of options
```

Как мы видим, компилятор создал несколько файлов в нашей директории. Давайте рассмотрим содержимое директории.
Если ваша цель — написать исполняемую программу, то по соглашению файл `main.zig` содержит код вашей основной функции main(), которая является точкой входа в программу, то есть именно с нее начинается выполнение кода.
Однако, если вы разрабатываете библиотеку, стандартная практика — удалить файл `main.zig` и начать с модуля `root.zig`. По соглашению, `root.zig` является основным исходным файлом вашей библиотеки.
Также при выполнении команды `init` были созданы еще два файла: `build.zig` и `build.zig.zon`. Они необходимы для установки дополнительных пакетов и сборки нашего приложения, но их мы рассмотрим позднее, а пока не будем заглядывать в них. Итак, давайте посмотрим, что же внутри файла `root.zig`:

```zig
const std = @import("std");
const testing = std.testing;

export fn add(a: i32, b: i32) i32 {
    return a + b;
}

test "basic add functionality" {
    try testing.expect(add(3, 7) == 10);
}
```

Здесь мы видим, что наш код начинается с импортирования стандартной библиотеки Zig. Вряд ли вы сможете написать полезное приложение, не импортировав ничего из стандартной библиотеки. Из нее нам необходим набор функций для тестирования, так как команда init также сгенерировала нам тесты для нашей простой функции. В целом синтаксис import очень схож с тем, как это устроено в других языках, таких как JavaScript или Go.
Далее мы видим функцию add, синтаксис которой очень похож на синтаксис языка Rust — мы используем fn для определения функции и определяем у нее два параметра с типом i32. Функция также вернет нам значение с типом i32 в результате своей работы. Так как Zig — строго типизированный язык, нам почти всегда будет необходимо указывать типы передаваемых значений.
Также мы можем заметить ключевое слово export, стоящее перед нашей функцией. Оно работает примерно так же, как extern в C, и говорит компилятору, что функция будет доступна наружу из нашей библиотеки.

Теперь давайте рассмотрим код нашего основного файла:

```zig
const std = @import("std");

pub fn main() !void {
    // Prints to stderr (it's a shortcut based on `std.io.getStdErr()`)
    std.debug.print("All your {s} are belong to us.\n", .{"codebase"});

    // stdout is for the actual output of your application, for example if you
    // are implementing gzip, then only the compressed bytes should be sent to
    // stdout, not any debugging messages.
    const stdout_file = std.io.getStdOut().writer();
    var bw = std.io.bufferedWriter(stdout_file);
    const stdout = bw.writer();

    try stdout.print("Run `zig build test` to run the tests.\n", .{});

    try bw.flush(); // don't forget to flush!
}

test "simple test" {
    var list = std.ArrayList(i32).init(std.testing.allocator);
    defer list.deinit(); // try commenting this out and see if zig detects the memory leak!
    try list.append(42);
    try std.testing.expectEqual(@as(i32, 42), list.pop());
}
```
Если мы взглянем на нашу функцию main, то первое, что бросится нам в глаза, — это странный тип возвращаемого значения. Тип void говорит компилятору, что наша функция не возвращает значения, но что за непонятный восклицательный знак в начале? Таким образом, в Zig указывается, что функция может возвращать ошибку. Полный синтаксис выглядит так: SomeError!void, но если мы опустим указание типа ошибки, то Zig выведет тип за нас на основе тех ошибок, что встретит в коде нашей программы. Если мы посмотрим код нашей функции, то неясно, а как же мы возвращаем эту самую ошибку. И тут в работу вступает ключевое слово `try`. Хоть оно и похоже на привычные нам try-catch, но работает это в Zig немного по-другому. В нашем примере мы видим использование `try` при вызове записи в stdout и при вызове flush. Если во время выполнения этих функций произойдет ошибка, то она автоматически будет возвращена из нашей функции. Если ошибки не будет, то конструкция `try` просто вернет значение, как будто ее и не было. Последнее, на что мы обратим внимание в нашей функции main, — это ключевое слово `pub`. По умолчанию все функции модуля в Zig приватные и недоступны вне модуля. Чтобы вызывающий код мог использовать вашу функцию, вам нужно пометить ее ключевым словом `pub`.

Итак, давайте наконец скомпилируем и запустим нашу простую программу. Для этого выполним команду:

```shell
zig build-exe
```

В результате выполнения этой команды в папке нашей программы появится директория zig-out с двумя поддиректориями:

```shell
./zig-out
├── bin
│   └── hello
└── lib
    └── libhello.a

3 directories, 2 files
```

Файл libhello.a в директории lib — это наша библиотека, которую мы статически линкуем к нашей программе. Расширение .a как раз говорит нам об этом. В директории bin мы видим исполняемый файл нашей программы, давайте попробуем ее запустить:

```shell
All your codebase are belong to us.
Run `zig build test` to run the tests.
```

Мы видим, что наша программа успешно выполнилась и вывела на экран то, что мы видели, когда смотрели код программы. Давайте теперь запустим наши тесты, выполнив команду `zig build test --summary all`.

```shell
$ zig build test --summary all
Build Summary: 5/5 steps succeeded; 4/4 tests passed
test success
├─ run test 1 passed 226ms MaxRSS:2M
│  └─ zig test Debug native success 975ms MaxRSS:250M
└─ run test 3 passed 437ms MaxRSS:2M
   └─ zig test Debug native success 984ms MaxRSS:245M
```

Параметр `--summary all` нужен чтобы увидеть вывод тестов, так как по умолчанию если тесты прошли успешно, то Zig ничего не выведет на экран.

## Заключение
Резюмируя все то, что мы узнали о языке Zig из первой главы, можно снова задаться вопросом: зачем нам еще один C-подобный язык? Ответ прост. Если Zig удастся снизить эксплуатационные расходы, улучшая опыт разработчиков, безопасность, качество и время выхода на рынок новых функций, то компаниям, пишущим на C/C++/Rust, придется конкурировать с теми, кто использует Zig. И если они не будут этого делать, то начнут проигрывать эту гонку и терять своих клиентов. Конечно, Zig пока еще далек от версии 1.0, и часто с выходом новой версии ваш код может сломаться. Также, если вы будете искать примеры кода в интернете или в GPT, то вероятно, что вы найдете уже неработающие примеры, так как язык сейчас активно меняется нередко что-то удаляется из языка, а что-то добавляется. Но язык уже набрал критическую массу, и я думаю, что выход первой версии уже не так далек, как в 2016 году.
