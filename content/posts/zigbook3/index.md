---
title: Простые типы данных
date: 2025-02-22 16:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
---

Zig — строготипизированный язык программирования, предоставляющий широкий набор встроенных типов данных. В этой главе мы рассмотрим основные скалярные типы данных, которые используются в Zig: целочисленные, числа с плавающей запятой, булевы, символьные, а также специальные типы void, nonreturn и null.

## Целочисленные типы
Целочисленный тип (integer) — это число без дробной части. Zig поддерживает как знаковые, так и беззнаковые целочисленные типы различных разрядностей. Они определяются с помощью iN (знаковые) и uN (беззнаковые), где N — количество бит в числе. Так например `u32` объявление типа указывает, что значение, с которым оно связано, должно быть целым числом без знака (типы целых чисел со знаком начинаются с i вместо u), которое занимает 32 бита памяти. Помимо стандартных привычных всем типов данных таких как `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128` и `i128` Zig также предоставляет типы `u1`, `i1`, `u2`, `i2`, `u4`, `i4`, `i47`, `u47`. Zig умеет работать с целыми числами произвольной длины (в битах). Конечно Вам возможно такие типы данных никогда не понадобятся, но вероятно есть случаи когда это может быть полезно.

Примеры целочисленных типов:

```zig
const a: i32 = -100; // Знаковое 32-битное число
const b: u8 = 255;   // Беззнаковое 8-битное число
```

Каждый вариант со знаком может хранить числа от $ -(2 ^ n - 1 ) $ до $ 2 ^ n - 1 - 1 $ включительно, где n — количество битов, которые использует этот вариант. Таким образом, i8 может хранить числа от $ -(2 ^ 7 ) $ до $ 2 ^ 7 - 1 $, что равно значениям от -128 до 127. Варианты без знака могут хранить числа от 0 до $ 2 ^ n - 1 $, поэтому u8 может хранить числа от 0 до $ 2 ^ 8 - 1 $, что равно значениям от 0 до 255.

Zig также поддерживает архитектурно-зависимые типы такие как `usize` и `isize`, размерность которых зависит от архитектуры компьютера, на котором выполняется программа.

```zig
var a: usize = 10;  // На компьютере с архитектурой x86_x64 размерность типа будет 64 бита
var b: isize = -10;
```

Для задания типа числового значения Вы также можете использовать литеральные суффиксы, если значение подразумевает возможность нескольких числовых типов:

```zig
var c = 10.0i32; // i32
var d = 10u64; // u64
```

Числовые литералы также могут использовать `_` в качестве визуального разделителя для облегчения чтения числа, например 1_000_000, который будет иметь такое же значение, как если бы было задано 1000000.

```zig
const large_number: u64 = 1_000_000_000; // 1 миллиард
const binary: u8 = 0b1100_1010; // 202 в десятичной системе
const hex: u32 = 0xFF_FF_FF_FF; // 4294967295 (максимум для u32)
const float: f64 = 3.1415_9265_3589; // Число π с разделением
```

Когда Вы работает с челочисленными типами определенной размерности, важно учитывать, что может произойти целочисленное переполнение. Допустим, имеется переменная типа u8, которая может хранить значения от 0 до 255. Если попытаться изменить переменную на значение вне этого диапазона, например, 256, произойдёт целочисленное переполнение. По умолчанию обычные арифметические операции (например, +, -, *, /) вызывают ошибку компиляции или панику во время выполнения, если происходит переполнение. Однако Zig также предоставляет оберточные (`%=`) и проверенные (`+|=`, `-|=`, `*|=`) операции для управления поведением переполнения.

```zig
const std = @import("std");

pub fn main() void {
    var x: u8 = 255;
    x += 1; // Ошибка: переполнение во время выполнения!
}
```

В случае использования обычных арифметических операторов поведение зависит от того в каком режиме скомпилирована ваша программа. Так если Вы скомпилировали Вашу программу в режиме debug, то операции будут вызывать ошибку компиляции или панику во время выполнения, если происходит переполнение. Если же Вы скомпилировали программу в режиме release, то компилятор может оптимизировать код и поведение становится неопределённым.

Если используется оператор `%=` (например, x +%= 1;), то происходит модульное переполнение, при котором значение “перекручивается” к нулю.

```zig
const std = @import("std");

pub fn main() void {
    var x: u8 = 255;
    x +%= 1; // Теперь x станет 0, без ошибки
    std.debug.print("x = {}\n", .{x});
}
```

Если нужно избежать переполнения и ограничить значение на границах диапазона, можно использовать `+|=`, `-|=`, `*|=`:

```zig
var y: u8 = 250;
y +|= 10; // y станет 255, а не переполнится в 0
```

Это полезно, например, для работы с цветами (ограничение диапазона 0–255).

## Числа с плавающей запятой
Также в Zig есть два примитивных типа для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Типы с плавающей точкой в Zig - это `f32` и `f64`, размер которых составляет 32 бита и 64 бита соответственно. Все типы с плавающей запятой являются знаковыми.

Вот пример, демонстрирующий числа с плавающей запятой в действии:

```zig
const std = @import("std");

pub fn main() void {
    const pi: f32 = 3.14159;
    const avogadro: f64 = 6.02214076e23;

    std.debug.print("pi = {d:.5}, avogadro = {e}\n", .{pi, avogadro});
}


# zig build run
pi = 3.14159, avogadro = 6.02214076e23
```

Числа с плавающей запятой представлены в соответствии со стандартом IEEE-754. Тип `f32` является плавающей запятой одинарной точности, а `f64` - двойной точности.

В стандартной библиотеки Zig вы также можете найти специальные значения для чисел с плавающей запятой, такие как бесконечность и NaN (Not a Number):

```zig
const std = @import("std");

pub fn main() void {
    const inf: f32 = std.math.inf(f32);
    const nan: f32 = std.math.nan(f32);

    std.debug.print("inf = {d}, nan = {d}\n", .{inf, nan});
}


# zig build run
inf = inf, nan = nan
```

## Числовые операции
Zig поддерживает основные математические операции, привычные для всех типов чисел: сложение, вычитание, умножение, деление и остаток.

|Операция|Оператор|Пример (u8 и i8)|
| ------------- | ------------- | ------------- |
|Сложение| + |x + y|
|Вычитание| - |x - y|
|Умножение| * |x * y|
|Деление| / |x / y|
|Остаток| % |x % y|

Целочисленное деление (`/`) в Zig всегда проверяется на деление на ноль и не выполняет автоматическое округление.

```zig
const std = @import("std");

pub fn main() void {
    const a: i32 = 10;
    const b: i32 = 3;
    std.debug.print("10 / 3 = {}\n", .{a / b}); // Выведет 3 (без округления)

    const x: i32 = 10;
    const y: i32 = 0;
    const result = x / y; // Ошибка компиляции: division by zero
}
```

Для приложения собранного в режиме debug деление на ноль вызовет панику, для приложения собранного в режиме release деление на ноль приведет к неопределенной ситуации.

Zig также поддерживает операции деления с округлением с помощью функций `@divFloor`, `@divTrunc`, `@divExact`:

|Функция|Описание|
| ------------- | ------------- |
|@divTrunc(a, b)|Отбрасывает дробную часть (стандартное поведение `/`)|
|@divFloor(a, b)|Округляет вниз (к наименьшему целому)|
|@divExact(a, b)|Делит без остатка, но вызывает ошибку, если a % b != 0|

Пример:

```zig
std.debug.print("divTrunc(10, 3) = {}\n", .{@divTrunc(10, 3)}); // 3
std.debug.print("divFloor(10, 3) = {}\n", .{@divFloor(10, 3)}); // 3
std.debug.print("divFloor(-10, 3) = {}\n", .{@divFloor(-10, 3)}); // -4
```

## Битовые операции
Zig также поддерживает стандартный набор битовых операций, таких как `&`, `|`, `^`, `<<`, `>>`, `~` и т.д.

Сдвиг влево сдвигает все биты числа на указанное количество позиций влево. Это эквивалентно умножению на $ 2^n $. Симметрично сдвиг вправо сдвигает все биты числа на указанное количество позиций вправо. Это эквивалентно делению на $ 2^n $.

```zig
const std = @import("std");

pub fn main() void {
    const a: u8 = 0b00001111; // 15
    const b = a << 2; // Сдвиг на 2 позиции влево

    std.debug.print("b = {b:0>8b}\n", .{b}); // 0b00111100 (60)
}
```

В Zig по разному происходит операция сдвига для знаковых и беззнаковых типов данных. Так, если мы сдвигаем беззнаковый тип, то свободные биты заполняются 0, а если знаковый, то они заполняются знаковым битом.

```zig
const a: u8 = 0b10000000;
const b = a >> 4; // 0b00001000 (8)

const a: i8 = -128; // 0b10000000 (-128)
const b = a >> 3;   // 0b11111000 (-16)
```

В Zig запрещены сдвиги на количество бит больше, чем размер типа. Например следующий код приведет к ошибке:

```zig
const a: u8 = 0b00000001;
const b = a << 8; // Ошибка! u8 имеет только 8 бит.
```

Стандартные битовые операции `&`, `|`, `^`, `~` в Zig ведут себя аналогично другим языкам:

```zig
const a: u8 = 0b1100_1100;
const b: u8 = 0b1010_1010;
const result = a & b; // 0b1000_1000 (0x88)

const a: u8 = 0b1100_1100;
const b: u8 = 0b1010_1010;
const result = a | b; // 0b1110_1110 (0xEE)

const a: u8 = 0b1100_1100;
const b: u8 = 0b1010_1010;
const result = a ^ b; // 0b0110_0110 (0x66)

const a: u8 = 0b1100_1100;
const result = ~a; // 0b0011_0011 (0x33)
```

Также Вы можете совершать операции над отдельными битами:

|   Операция    |      Код      |  Применение   |
| ------------- | ------------- | ------------- |
| Маскирование  | x & mask | Извлечение битов |
| Установка бита | `x | (1 << n)` |
| Сброс бита | x & ~(1 << n) | Выключение флага |
| Инверсия бита | x ^ (1 << n) | Переключение флага |
| Проверка бита | (x & (1 << n)) != 0 | Определение состояния |

```zig
const flags: u8 = 0b0000_0000;
const new_flags = flags | (1 << 3); // Установить 3-й бит

const flags: u8 = 0b0000_1000;
const new_flags = flags & ~(1 << 3); // Сбросить 3-й бит

const flags: u8 = 0b0000_1000;
const is_set = (flags & (1 << 3)) != 0;
```

## Логический тип данных
Как и в большинстве других языков программирования, логический тип в Zig имеет два возможных значения: `true` и `false`. Значения логических типов имеют размер в один байт. Логический тип в Zig задаётся с помощью `bool`. В отличие от языка C Zig не приводит 0 и 1 (или любые другие числа) к булевому типу `bool` автоматически и требуется явное приведение типов, с использованием функций `@intToBool` или `@boolToInt`. Например:

```zig
const is_ready: bool = true;
const is_empty: bool = false;


const flag: bool = 1; // Ошибка: expected type 'bool', found 'comptime_int'
std.debug.print("flag = {}\n", .{flag});

const flag: bool = @intToBool(1); // А вот так будет работать
std.debug.print("flag = {}\n", .{flag});
```

## Символьный тип данных
Zig не имеет отдельного типа `char`, но символы могут быть представлены как 8-битные или 21-битные числа (соответствующие кодам ASCII или Unicode). Например:

```zig
const std = @import("std");

pub fn main() !void {
    const letter: u8 = 'A';

    std.debug.print("{}\n", .{letter});

    const stdout = std.io.getStdOut().writer();
    var buffer: [4]u8 = undefined; // UTF-8 encoding requires max 4 bytes for a Unicode character

    const emoji: u21 = '😻';

    const encoded_len = try std.unicode.utf8Encode(emoji, &buffer);
    try stdout.writeAll(buffer[0..encoded_len]);
}
```

К сожалению стандартная функция print из пакета debug не поддерживает вывод симолов в формате Unicode, поэтому для этого нам приходится использовать запись в стандартный консольный вывод.

## Тип void и noreturn
В Zig существуют два специальных типа: `void` и `noreturn`, которые используются для разных целей. Тип `void` означает, что функция не возвращает полезного значения, но успешно выполняется.

```zig
const std = @import("std");

pub fn sayHello() void {
    std.debug.print("Hello, Zig!\n", .{}); // Только побочный эффект
}

pub fn main() void {
    sayHello(); // Вызываем функцию, она ничего не возвращает
}
```

Тип `noreturn` означает, что функция никогда не завершится “нормально”. Она либо вызовет панику, либо зациклится, либо завершит программу.

```zig
pub fn crash() noreturn {
    @panic("Something went wrong!"); // Завершает программу
}

pub fn infiniteLoop() noreturn {
    while (true) {} // Функция никогда не завершится
}

pub fn main() void {
    crash(); // Никогда не вернёт управление

    infiniteLoop(); // Никогда не вернёт управление
}
```

## Опциональный тип данных
В Zig нет null-указателей как в C, но есть опциональные типы (?T), которые могут содержать либо T, либо `null`.

```zig
const std = @import("std");

pub fn main() void {
    var maybe_number: ?i32 = null; // Может быть числом или null
    std.debug.print("maybe_number = {}\n", .{maybe_number});
}
```

Перед использованием опционального значения нужно проверить, не равно ли оно `null`. Есть два способа сделать такую проверку. Наиболее частый это использование условного оператора `if`:

```zig
if (maybe_number) |num| {
    std.debug.print("Число: {}\n", .{num});
} else {
    std.debug.print("Значение отсутствует!\n", .{});
}
```

В этом примере если значение `maybe_number` не равно `null`, то сработает первый блок нашего условного оператора и значение будет переданно в параметре `num`, если же `maybe_number` равно `null`, то сработает второй блок и будет выведено сообщение "Значение отсутствует!". Есть также более компактная форма с использованием `orelse`:

```zig
  std.debug.print("Число: {}\n", .{num orelse 0});
```

Второй вариант проверки это принудительно разыменовать ?T, но если значение `null`, программа завершится с ошибкой.

```zig
const value: i32 = maybe_number.?; // ⚠️ Паника, если null!
```

## Приведение и вывод типов
В языке программирования Zig существует два типа приведения: явное и неявное. Эти принципы важны для обеспечения безопасности типов и контроля над типами данных, что делает код более предсказуемым и безопасным.

### Явное приведение типов

Явное приведение типов в Zig осуществляется с помощью оператора приведения `@intCast`, `@intFromFloat` и `@floatFromInt`. Это приведение используется, когда программист явно указывает, что он хочет преобразовать один тип в другой. Например:

```zig
const x: u32 = 42;
const y: u8 = @intCast(u8, x); // Явное приведение типа u32 в u8
```

Здесь мы явно приводим значение типа `u32` в тип `u8` с помощью функции `@intCast`. В Zig это может быть полезно, когда вам нужно преобразовать типы данных, например, из более широких в более узкие. Функция `@intFromFloat` выполнит конвертацию числа с плавающей запятой (f16, f32, f64, f128) в целочисленный (iN, uN) тип путём усечения. Если при этом число выйдет за пределы, то произойдет паника. Функция `@floatFromInt` произведет обратное преобразования, но оно в отличии от предыдущего не может привести к панике.

Язык Zig для явного приведения типа также поддерживает оператор `@as`. Общий синтаксис оператора `@as` выглядит так:

```zig
@as(TargetType, Value)
```
*	TargetType: тип, к которому вы хотите привести значение.
*	Value: выражение или переменная, которую вы хотите привести.

Этот оператор позволяет привести значение к определенному типу. Однако важно помнить, что при использовании `@as` необходимо учитывать, что если приведение невозможно или приводит к ошибке (например, из-за переполнения или потери данных), компилятор выдаст ошибку.

```zig
const std = @import("std");

pub fn main() void {
    const a: u32 = 42;
    const b: u8 = @as(u8, a); // Приведение u32 к u8

    std.debug.print("Значение b: {}\n", .{b}); // Вывод значения b

    const a: u32 = 500;
    const b: u8 = @as(u8, a); // Ошибка: 500 не помещается в u8

    std.debug.print("Значение b: {}\n", .{b});
}
```

Zig не делает неявного приведения типов, чтобы избежать ошибок, связанных с переполнением, потерей данных или неожиданными преобразованиями типов. Когда вы используете `@as`, вы явно сообщаете компилятору, что приведение безопасно в вашем контексте, и если оно не может быть выполнено, компилятор сообщит об ошибке.

### Неявное приведение типов

Неявное приведение типов в Zig происходит автоматически в ситуациях, где компилятор сам может безопасно привести один тип в другой без явного указания программистом. Однако важно заметить, что Zig по умолчанию старается избегать неявных приведений типов. Это сделано для того, чтобы избежать потенциальных ошибок, связанных с неожиданными преобразованиями типов.

Пример неявного приведения:

```zig
const a: u8 = 5;
const b: u32 = a; // Неявное приведение типа u8 в u32
```

В этом примере `u8` автоматически приводится к `u32` без явного указания программиста, потому что `u32` — это более широкий тип, и такая операция безопасна. Однако если бы типы были несовместимы или приведение могло привести к потере данных, компилятор бы выдал ошибку.

### Вывод типа
В языке программирования Zig можно использовать функцию `@TypeOf`, чтобы получить тип переменной или выражения на этапе компиляции. Это полезно, когда нужно получить тип для отладки, или для использования в метапрограммировании (например, для создания универсальных функций или шаблонов).

Пример:

```zig
const std = @import("std");

const foo = 42; // переменная типа i32
const bar = 3.14; // переменная типа f64

const foo_type = @TypeOf(foo); // получаем тип переменной foo
const bar_type = @TypeOf(bar); // получаем тип переменной bar

pub fn main() void {
    std.debug.print("Тип переменной foo: {}\n", .{foo_type});
    std.debug.print("Тип переменной bar: {}\n", .{bar_type});
}

# zig build run
Тип переменной foo: i32
Тип переменной bar: f64
```

В приведенном примере мы получаем типы переменных foo и bar с помощью `@TypeOf` и выводим их через std.debug.print. Более подробно мы рассмотрим использование `@TypeOf` в следующих главах, но так как на данном этапе иногда полезно узнать, что за тип неявно вывел zig Вы можете узнать это используя `@TypeOf`.

## Типы этапа компиляции
В zig есть два специальных типа используемых на этапе компиляции `comptime_int` и `comptime_float`.Эти типы вычисляются на этапе компиляции и не имеют фиксированной разрядности (например, `i32`, `u64`). Они автоматически преобразуется в нужный тип.

Пример: присвоение comptime_int

```zig
const x = 10; // x — comptime_int
const y: i32 = x; // Автоматическое преобразование в i32
```

В данном пример число 10 является `comptime_int`, но Zig автоматически приводит его к `i32`.

Пример: использование comptime_int для вычислений на этапе компиляции

```zig
const x = 5 * 10; // x = comptime_int
const y: u8 = x + 2; // Авто-приведение в u8
```

Более подробно мы коснемся типов этапа компиляции, когда будем изучать универсальные типы и функции.
