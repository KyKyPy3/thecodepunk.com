---
title: Срезы и строки
date: 2025-02-28 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
---
Срезы в Zig — это мощный инструмент для работы с последовательностями элементов. Они представляют собой структуру данных, которая содержит указатель на начало последовательности и её длину. По сути, срезы можно рассматривать как "вид" на подмножество массива или область памяти. Эта концепция будет знакома разработчикам, которые работали с такими языками, как Rust или Go.

## Объявление и создание срезов

Тип среза в Zig обозначается как `[]T`, где `T` — это тип элементов. Например, `[]u8` представляет срез беззнаковых 8-битных целых чисел, а `[]const u8` — срез, элементы которого не могут быть изменены (что часто используется для строк).

Если Вы попробуете создать срез из массива или из части массива, но при этом границы вашего среза будут известны на этапе компиляции, то на самом деле вы создадите не срез, а просто указатель на массив. Давайте рассмотрим эти два сценария:

```zig
const std = @import("std");

pub fn main() void {
    // Исходный массив
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание среза всего массива
    const slice1 = &array;

    std.debug.print("Slice1 type: {}\n", .{@TypeOf(slice1)});

    // Создание среза части массива
    const slice2 = array[1..3];

    std.debug.print("Slice2 type: {}\n", .{@TypeOf(slice2)});
}
```

Этот код выведет следующее:

```
Slice1 type: *[5]i32
Slice2 type: *[2]i32
```

Как видно, в обоих случаях создаются указатели на массивы, а не срезы. Чтобы явно создать срез, нужно указать тип переменной как тип среза, либо чтобы параметры среза были не известны на этапе компиляции:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание среза элементов со 2-го по 4-й (индексы 1-3). Мы явно указываем тип среза
    const slice1: []i32 = array[1..4];

    std.debug.print("Slice1 type: {}\n", .{@TypeOf(slice1)});

    var start: usize = 1;
    var end: usize = 4;
    _ = &start; // Здесь мы берем адрес переменной start, чтобы компилятор не ругался что переменная не изменяется
    _ = &end; // Здесь мы берем адрес переменной end, чтобы компилятор не ругался что переменная не изменяется

    const slice2 = array[start..end];
    std.debug.print("Slice2 type: {}\n", .{@TypeOf(slice2)});
}
```

В результате мы получим вывод:

```
Slice1 type: []i32
Slice2 type: []i32
```

Еще один из вариантов определения среза, это использование рассмотренных ранее аллокаторов. Это полезно, когда размер среза неизвестен на этапе компиляции:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Создание среза с выделением памяти
    const dynamic_slice = try allocator.alloc(i32, 5);
    defer allocator.free(dynamic_slice);

    // Заполнение среза
    for (dynamic_slice, 0..) |*item, i| {
        item.* = @intCast(i + 1);
    }

    // Вывод среза
    for (dynamic_slice) |item| {
        std.debug.print("{} ", .{item});
    }
    std.debug.print("\n", .{});
}
```

Этот код выведет:

```
1 2 3 4 5
```

Для создания среза необязательно использовать массив — вы можете создавать срезы из других срезов. Это особенно удобно при написании парсеров, когда нужно сохранять разобранные конструкции внутри полной строки.

Например, можно сначала взять срез от части строки, выделив фрагмент по разделителю (например, символу новой строки `\n`), а затем сохранить полученные срезы в словаре или массиве для дальнейшей обработки.

Рассмотрим пример получения среза из другого среза:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание среза элементов со 2-го по 4-й (индексы 1-3). Мы явно указываем тип среза
    const slice1: []i32 = array[1..4];

    std.debug.print("Slice type: {}, len: {}\n", .{ @TypeOf(slice1), slice1.len });

    const slice2: []i32 = slice1[1..3];
    std.debug.print("Slice type: {}, len: {}\n", .{ @TypeOf(slice2), slice2.len });
}
```

Этот код выведет:

```
Slice type: []i32, len: 3
Slice type: []i32, len: 2
```

В этом случае оба среза указаывают на один и тот же массив, поэтому изменения в одном срезе будут отражаться в другом. Работая со срезами Вы всегда можете получить текущую длину среза через `slice.len`.

### Доступ к элементам среза

Доступ к элементам среза осуществляется так же, как и к элементам массива — с помощью оператора индексации `[]`. При этом, так как в состав типа среза включена его длина, компилятор при обращении к элементам среза проверит, нет ли выхода за его пределы.

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };
    var slice: []i32 = array[0..];

    // Доступ к элементу по индексу
    const third_element = slice[2];
    std.debug.print("Третий элемент: {}\n", .{third_element});

    // Изменение элемента по индексу
    slice[0] = 10;
    std.debug.print("Обновленный первый элемент: {}\n", .{slice[0]});

    slice[10] = 100; // Тут будет ошибка выхода за пределы среза
}
```

Этот код не скомпилируется из-за последней строчки, но если мы ее уберем, то получим следующий вывод:

```
Третий элемент: 3
Обновленный первый элемент: 10
```

### Модификация срезов

Важно понимать, что срезы — это "проекция" на существующие данные. Когда вы модифицируете элемент среза, вы фактически изменяете соответствующий элемент в базовом массиве или области памяти:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создаем два среза на один и тот же массив
    var slice1: []i32 = array[0..3];
    var slice2: []i32 = array[2..5];

    // Изменяем общий элемент через первый срез
    slice1[2] = 30;

    // Проверяем, что изменение отразилось и во втором срезе
    std.debug.print("slice2[0] = {}\n", .{slice2[0]});
    // Вывод: slice2[0] = 30

    // Проверяем, что изменение отразилось в исходном массиве
    std.debug.print("array[2] = {}\n", .{array[2]});
    // Вывод: array[2] = 30
}
```

Помимо изменения отдельных элементов, срезы можно объединять с помощью аллокаторов. Для этого необходимо выделить новую область памяти, достаточную для хранения данных из обоих срезов, а затем скопировать в неё их содержимое.

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var slice1 = [_]i32{ 1, 2, 3 };
    var slice2 = [_]i32{ 4, 5, 6 };

    // Создаем новый срез, который вместит оба среза
    var result = try allocator.alloc(i32, slice1.len + slice2.len);
    defer allocator.free(result);

    // Копируем данные из первого среза
    std.mem.copyForwards(i32, result[0..slice1.len], &slice1);

    // Копируем данные из второго среза
    std.mem.copyForwards(i32, result[slice1.len..], &slice2);

    // Выводим результат
    for (result) |item| {
        std.debug.print("{} ", .{item});
    }
    std.debug.print("\n", .{});
    // Вывод: 1 2 3 4 5 6
}
```

Иногда чтобы изменить элемент Вам необходимо его найти в срезе. Для этого можно использовать функции стандартной библиотеки в Zig:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };
    const slice = &array;

    // Поиск первого вхождения элемента 3
    const index = std.mem.indexOf(i32, slice, &[_]i32{3});

    if (index) |i| {
        std.debug.print("Элемент 3 найден на позиции {}\n", .{i});
    } else {
        std.debug.print("Элемент 3 не найден\n", .{});
    }
}
```

Здесь мы используем функцию `std.mem.indexOf` для поиска первого вхождения элемента 3 в срезе `slice`. Если элемент найден, то функция вернет индекс первого вхождения, иначе вернет `null`. Мы используем оператор `?` для обработки возможного `null` значения.

### Sentinel срезы
Как и массивы в Zig, срезы могут быть sentinel-срезами (срезами с ограничительным маркером). Sentinel-срез - это срез, который завершается маркерным значением. Это позволяет использовать срезы в функциях, которые ожидают, что срез будет завершен например нулевым значением. Это особенно полезно для совместимости с C-строками, которые заканчиваются нулевым байтом:

```zig
const std = @import("std");

pub fn main() void {
    // Создаем sentinel срез, заканчивающийся нулем
    var sentinel_array = [_]u8{ 'h', 'e', 'l', 'l', 'o', 0 };
    const sentinel_slice: [:0]u8 = sentinel_array[0..5 :0];

    // В sentinel_slice автоматически добавляется маркер '0' после 'o'
    std.debug.print("Длина среза: {}\n", .{sentinel_slice.len});
    // Вывод: Длина среза: 5

    // Доступ к срезу
    const sentinel = sentinel_slice[sentinel_slice.len];
    std.debug.print("Sentinel: {}\n", .{sentinel});
    // Вывод: Sentinel: 0
}
```

Тип такого sentinel среза обозначается как `[:sentinel]T`, где `sentinel` — это значение-маркер. В нашем примере маркером конца среза является `0`.

## Строки
В языке программирования Zig строки не являются примитивным типом, а скорее концепцией, построенной на более фундаментальных элементах. Этот подход обеспечивает как силу, так и гибкость, но требует более глубокого понимания для освоения. Zig строки представлены как срезы константных беззнаковых 8-битных целых чисел (`[]const u8`). Это означает, что все рассмотренные выше операции со срезами применимы и к строкам.

Однако при работе с текстовыми данными в Zig есть некоторые особенности и дополнительные функции. По умолчанию строки в Zig должны быть в кодировке UTF-8. Однако, поскольку срез `[]u8` представляет собой просто массив байтов, он может содержать любые данные, а не только корректные символы UTF-8. Из-за этого работа со строками в Zig может показаться менее удобной по сравнению с Go или Rust.

Для того чтобы создать строку проще всего использовать литералы строк. Например:

```zig
const std = @import("std");

pub fn main() void {
    const greeting = "Hello, World!";

    std.debug.print("Sting type in zig: {}\n", .{@TypeOf(greeting)});
}
```

Мы получим вывод:

```
$ zig build run
Sting type in zig: *const [13:0]u8
```

Строки созданные с помощью строковых литералов в Zig -  это sentinel строки с маркером `0` и типом данных `[]const u8`. Компилятор автоматически приводит тип нашей строки к типу `[:0]const u8`. Это сделанно для более удобной совместимости с языком C. Хотя конечно можно создавать строки из массивов символов:

```zig
const char_array = [_]u8{ 'H', 'e', 'l', 'l', 'o' };
const hello_string: []const u8 = &char_array;
```

### Управляющие последовательности

В Zig, как и во многих других языках программирования, вы можете использовать управляющие последовательности (escape-sequences) для представления специальных символов в строках. Эти последовательности начинаются с обратного слэша (`\`) и позволяют вставлять символы, которые невозможно напрямую написать в строке, такие как символы новой строки, табуляции и другие.

Вот наиболее часто используемые управляющие последовательности в Zig:
* \n — символ новой строки (newline).
* \t — символ табуляции (tab).
* \\ — обратный слэш (backslash).
* \" — двойная кавычка (double quote).
* \' — одинарная кавычка (single quote).
* \r — возврат каретки (carriage return).
* \0 — нулевой символ (null character).

Символ `\n` используется для перехода на новую строку. Это полезно, например, при выводе текста с разделением на строки:

```zig
const std = @import("std");

pub fn main() void {
    std.debug.print("Первая строка\nВторая строка\nТретья строка\n", .{});
}
```

Вывод данного кода:
```
Первая строка
Вторая строка
Третья строка
```

В Zig многострочные строки можно создавать с помощью управляющих последовательностей `\n`. Однако, если строка слишком длинная, её можно разбить на несколько строк с использованием конкатенации:

```zig
const std = @import("std");

pub fn main() void {
    const message =
        "Это длинная строка, " ++
        "разделенная на несколько " ++
        "строк для удобства чтения.\n";
    std.debug.print("{s}", .{message});
}
```

Вывод:

```
Это длинная строка, разделенная на несколько строк для удобства чтения.
```

В Zig также поддерживаются сырые строки (raw strings), которые игнорируют управляющие последовательности. Они полезны, когда нужно вставить текст без обработки специальных символов. Сырые строки обозначаются с помощью `\\`:

```zig
const std = @import("std");

pub fn main() void {
    const raw_string = \\Это сырая строка. \n и \t не будут обработаны.;
    std.debug.print("{s}\n", .{raw_string});
}
```

Вывод:

```
Это сырая строка. \n и \t не будут обработаны.
```

Важно отметить, что по умолчанию Zig рассматривает строки как последовательности байтов, а не символов Unicode. Для работы с Unicode вам может понадобиться использовать специализированные библиотеки или функции стандартной библиотеки, которые могут интерпретировать UTF-8, UTF-16 или другие кодировки.

Базовая работа с UTF-8 строками может выглядеть так:

```zig
const std = @import("std");

pub fn main() !void {
    // UTF-8 строка с не-ASCII символами
    const utf8_string = "Привет, мир! 🌍";

    // Получаем итератор по UTF-8 кодовым точкам
    var utf8_iter = std.unicode.Utf8Iterator{
        .bytes = utf8_string,
        .i = 0,
    };

    // Итерируемся по кодовым точкам
    while (utf8_iter.nextCodepoint()) |codepoint| {
        // Выводим кодовую точку Unicode и её десятичное значение
        std.debug.print("{u}", .{codepoint});
    }
    std.debug.print("\n", .{});
}
```

В данном примере мы используем стандартную библиотеку Zig для работы с UTF-8 строками. Мы создаем UTF-8 строку с не-ASCII символами и получаем итератор по UTF-8 кодовым точкам. Затем мы итерируемся по кодовым точкам и выводим их Unicode и десятичное значение. Это конечно не так удобно как работа с рунами в языке Go, но тем не менее не заставляет Вас самому обрабатывать части UTF-8 символа.

Кроме стандартных строк Вам возможно прийдется тесно работать со строками в стиле языка C, так как Zig тесно интегрируется с кодом на C. Для того чтобы работать с такими строками Вам надо использовать sentinel срезы, которые мы рассматривали ранее:

```zig
const std = @import("std");

pub fn main() void {
    // Обычная строка
    const zig_string = "Hello";

    // Получаем C-строку (нуль-терминированную)
    const c_string: [*:0]const u8 = zig_string.ptr;

    // Для демонстрации вызываем C-функцию, принимающую C-строку
    const length = strlen(c_string);
    std.debug.print("Длина строки: {}\n", .{length});
}

// Объявление внешней C-функции
extern fn strlen(s: [*:0]const u8) usize;
```

Так как строки это обычные срезы, то мы можем обьединять строки используя оператор `++`:

```zig
const std = @import("std");

pub fn main() !void {
    const str1 = "Hello, ";
    const str2 = "World!";

    const result = str1 ++ str2;

    std.debug.print("{s}\n", .{result});
}
```

В случае если мы используем рантайм строки, то в стандартной библиотеке Zig также есть более удобные функции для работы со строками, включая `std.fmt.allocPrint` которая позводит обьеденить строки:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const name = "World";
    const greeting = try std.fmt.allocPrint(allocator, "Hello, {s}!", .{name});
    defer allocator.free(greeting);

    std.debug.print("{s}\n", .{greeting});
    // Вывод: Hello, World!
}
```

### Сравнение и поиск строк
Для того чтобы сравнить строки в Zig мы не можем просто сравнить два массива. Для сравнения строк нам необходимо использовать функцию `std.mem.eql` которая сравнивает два массива байтов и возвращает `bool`:

```zig
const std = @import("std");

pub fn main() void {
    const str1 = "hello";
    const str2 = "hello";
    const str3 = "world";

    const are_equal1 = std.mem.eql(u8, str1, str2);
    const are_equal2 = std.mem.eql(u8, str1, str3);

    std.debug.print("str1 == str2: {}\n", .{are_equal1});
    // Вывод: str1 == str2: true

    std.debug.print("str1 == str3: {}\n", .{are_equal2});
    // Вывод: str1 == str3: false
}
```

Для поиска подстроки в строке нам необходимо использовать функцию `std.mem.indexOf` которая возвращает индекс первого вхождения подстроки в строке или `null` если подстрока не найдена:

```zig
const std = @import("std");

pub fn main() void {
    const text = "Hello, World!";
    const substring = "World";

    const index = std.mem.indexOf(u8, text, substring);

    if (index) |i| {
        std.debug.print("Подстрока '{s}' найдена на позиции {}\n", .{substring, i});
    } else {
        std.debug.print("Подстрока '{s}' не найдена\n", .{substring});
    }
    // Вывод: Подстрока 'World' найдена на позиции 7
}
```

Для того чтобы провести замену подстроки в строке нам необходимо использовать функцию `std.mem.replaceOwned`:

```zig
const std = @import("std");

pub fn main() !void {
    const haystack = "Добро пожаловать в увлекательный мир программирования!";

    // Replacing (note: this creates a new string)
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    const new_string = try std.mem.replaceOwned(u8, allocator, haystack, "увлекательный", "удивительный");
    defer allocator.free(new_string);

    std.debug.print("Новая строка: {s}\n", .{new_string});
}
```

Этот код выведет:

```
Новая строка: Добро пожаловать в удивительный мир программирования!
```

Это далеко не все возможности, которые Zig предоставляет для работы со строками. Более полный список Вы можете найти в стандартной документации языка.

### Unicode символы
Иногда возникает необходимость сохранить одиночный символ Unicode в переменной. Какой же тип данных для этого использовать — `u32` или `u8`?

В языке Zig выбран довольно необычный подход, который поначалу может сбить с толку: символы Unicode представлены типом `u21`. Этот формат использует 21 бит, чего достаточно для хранения большинства символов Unicode. В отличие от `u32`, он позволяет экономить память в некоторых случаях.

Мы уже обсуждали символьный тип в главе 3. Если вам нужно освежить эту информацию, рекомендуем вернуться к ней.

## Стандартный потоки ввода и вывода
Раз уж мы коснулись в этой главе строк, давайте рассмотрим, как в программе на Zig работать со стандартным вводом и выводом, а также изучим форматирование строк при выводе данных.

В Unix-подобных операционных системах стандартный ввод и стандартный вывод представлены файлами с именами `/dev/stdin`, `/dev/stdout` и `/dev/stderr` соответственно. В Zig эти файлы доступны через функции:

- `std.io.getStdIn()` — для стандартного ввода
- `std.io.getStdOut()` — для стандартного вывода
- `std.io.getStdErr()` — для стандартного потока ошибок

На самом деле мы уже использовали в наших программах неявный вывод в `/dev/stderr` при использовании функции `std.debug.print()`. Эта функция выводит сообщение в стандартный поток ошибок.

Если мы хотим явно работать в программе на Zig со стандартными потоками ввода и вывода, то нам необходимо использовать функции `std.io.getStdIn()`, `std.io.getStdOut()` и `std.io.getStdErr()` для получения соответствующих потоков ввода и вывода.

Давайте рассмотрим явный вывод сообщений в стандартный поток вывода `/dev/stdout`:

```zig
const std = @import("std");

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();

    try stdout.print("Привет, мир!\n", .{});
}
```

Этот код выведет:

```
Привет, мир!
```

Обычно при работе с потоками вывода, такими как `/dev/stdout`, принято использовать буферизированный вывод, чтобы уменьшить количество системных вызовов и улучшить производительность. Для этого нам необходимо обернуть наш поток вывода в буферизированный вывод:

```zig
const std = @import("std");

pub fn main() !void {
    const stdout_stream = std.io.getStdOut().writer();
    var bw = std.io.bufferedWriter(stdout_stream);
    const stdout = bw.writer();

    try stdout.print("Привет, мир!\n", .{});

    try bw.flush();
}
```

В данном коде мы оборачиваем стандартный поток вывода буфферезированным писателем (`std.io.bufferedWriter`), чтобы обеспечить эффективное и безопасное взаимодействие с потоком вывода. После этого мы получаем интерфейс для записи в буферизованный писатель, записываем нашу строку и в конце вызываем `flush` для отправки данных в поток вывода. Если мы уберем вызов `flush`, данные не будут отправлены в поток вывода, и они будут потеряны.

При выводе строк мы можем использовать различные спецификаторы для форматирования данных. Общий шаблон для указания спецификаторов выглядит следующим образом:

```[аргумент][спецификатор]:[заполнитель][выравнивание][ширина].[точность]```

Где:

* аргумент – номер аргумента (необязательно, обычно используется порядковый)
* спецификатор – тип данных (d, x, s и т. д.)
* заполнитель – символ, используемый для заполнения (например, 0 для чисел)
* выравнивание:
  * \< – выравнивание влево
  * \> – выравнивание вправо
  * \^ – выравнивание по центру
* ширина – минимальная ширина поля (например, 5 для отступа в 5 символов)
* точность – количество знаков после запятой для чисел с плавающей точкой

Давайте рассмотрим примеры использования форматирования строк в Zig:

```zig
const std = @import("std");

pub fn main() void {
    std.debug.print("{} {0d}\n", .{3.14}); // Выводим один аргумент разными способами
    std.debug.print("[{s:<10}]\n", .{"Left"}); // Выравнивание влево
    std.debug.print("[{s:>10}]\n", .{"Right"}); // Выравнивание вправо
    std.debug.print("[{s:^10}]\n", .{"Center"}); // Выравнивание по центру
    std.debug.print("[{d:05}]\n", .{42}); // Число с нулями перед ним
    std.debug.print("[{d:.2}]\n", .{3.14159}); // Число с плавающей точкой, 2 знака после запятой
}
```

Выведет:

```
3.14e0 3.14
[Left      ]
[     Right]
[  Center  ]
[00042]
[3.14]
```

Также при выводе данных мы можем использовать спецификаторы для вывода в различных форматах, например, `%d` для целых чисел и `%s` для строк. Вот популярный список спецификаторов:

| Спецификатор | Описание |
| --- | --- |
| `x` и `X` | вывод числа в шестнадцатеричном формате |
| `s` | вывод строки (как С-строки так и обычной) |
| `e` | вывод числа с плавающей точкой в научной нотации |
| `d ` | вывод числа в десятичной системе |
| `b` | вывод целого числа в двоичной системе |
| `o` | вывод целого числа в восьмеричной системе |
| `c` | вывод целого числа как ASCII-символа |
| `?` | вывод optional значения (либо развернутое значение, либо null) |
| `u` | вывод целого числа как UTF-8 последовательности |
| `*` | вывод адреса значения вместо самого значения |
| `!` | вывод значения error union (либо развернутое значение, либо форматированная ошибка) |
| `any` | вывод значения любого типа в его стандартном формате |

Давайте рассмотрим пример:

```zig
const std = @import("std");

pub fn main() void {
    const num: u8 = 42;
    std.debug.print("{}\n", .{num});
    std.debug.print("{b}\n", .{num});
    std.debug.print("{o}\n", .{num});
    std.debug.print("{x}\n", .{num});
    std.debug.print("{c}\n", .{num});
    std.debug.print("{u}\n", .{num});
    std.debug.print("{any}\n", .{num});
}
```

Выведет:

```
42
101010
52
2a
*
*
42
```

Это не все возможности использования спецификаторов, некоторые мы расмотрим когда будем изучать структуры и ошибки.

Теперь давайте рассмотрим как читать данные из стандартного потока ввода. Для этого по аналогии с `stdout`, нам надо получить аналогичным образом ссылку на `stdin`. Вот пример использования стандартного потока ввода:

```zig
const std = @import("std");

pub fn main() !void {
    var stdin = std.io.getStdIn().reader();
    var buffer: [1024]u8 = undefined;

    const line = try stdin.readUntilDelimiterOrEof(&buffer, '\n');

    if (line) |text| {
        std.debug.print("{s}\n", .{text});
    } else {
        std.debug.print("Нет ввода\n", .{});
    }
}
```

В этом примере мы получаем стандартный поток ввода с помощью `std.io.getStdIn()`, а затем мы обьявляем буффер в который будем записывать ввод пользователя. Мы используем функцию `readUntilDelimiterOrEof`, которая читает из стандартного потока ввода пока не встретится символ новой строки (`\n`) и возвращает прочитанные данные. Так как функция может вернуть ошибку, мы используем оператор `if` чтобы проверить ошибку и если все хорошо, то мы выведем то, что ввел пользователь. Если мы запустим нашу программу и введем `Привет мир!`, то мы должны увидеть `Привет мир!`:

```
$ zig build run
Привет мир!
Привет мир!
```

Давайте рассмотрим ситуацию, когда нам нужно вывести форматированную строку не в стандартные потоки вывода, а сохранить её в переменной. Для этого стандартная библиотека Zig предоставляет две функции: `std.fmt.bufPrint` и `std.fmt.allocPrint`. Вначале разберём `std.fmt.bufPrint`.

Эта функция принимает заранее выделенный буфер, форматированную строку и аргументы для подстановки. Затем она записывает результат в буфер, позволяя сохранять строки в переменных для последующего использования. Давайте рассмотрим пример:

```zig
const std = @import("std");

pub fn main() !void {
    var buffer: [50]u8 = undefined; // Статический буфер на 50 байт

    const result = try std.fmt.bufPrint(&buffer, "Привет, {s}! Вам {d} лет.", .{"Алиса", 25});

    std.debug.print("{s}\n", .{result}); // Вывод: Привет, Алиса! Вам 25 лет.
}
```

В этом примере мы создаём буфер, который будет использоваться для форматирования строки. Важно: размер буфера должен быть достаточным для хранения всей строки, иначе будет выброшено исключение `std.fmt.BufError`.

После успешного форматирования `std.fmt.bufPrint` возвращает срез байтов ([]u8), содержащий готовую строку. Этот срез ссылается на тот же буфер, который мы передали в функцию, но его длина соответствует только длине отформатированной строки, а не размеру всего буфера.

Этот метод удобен, так как позволяет избежать динамического выделения памяти и эффективно управлять форматированием строк, используя заранее подготовленный буфер. Это делает `std.fmt.bufPrint` отличным выбором в ситуациях, когда важно контролировать использование памяти и избегать ненужных аллокаций.

Теперь давайте рассмотрим функцию `std.fmt.allocPrint`. Мы уже использовали её, когда нужно было объединить две строки. Эта функция особенно полезна, когда заранее неизвестен размер буфера, который сможет вместить всю форматированную строку. Давайте взглянем на код:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){}; // Создаём аллокатор
    defer gpa.deinit(); // Освобождаем память при завершении программы
    const allocator = gpa.allocator();

    // Динамическое форматирование строки с выделением памяти
    const formatted_str = try std.fmt.allocPrint(allocator, "Привет, {s}! Вам {d} лет.", .{"Алиса", 25});

    std.debug.print("{s}\n", .{formatted_str}); // Вывод: Привет, Алиса! Вам 25 лет.

    allocator.free(formatted_str); // Освобождаем выделенную память
}
```

В этом примере мы используем стандартный аллокатор `GeneralPurposeAllocator` и передаём его в функцию `allocPrint`. Она использует аллокатор для выделения памяти под форматированную строку. После форматирования строки, функция вернет нам результат форматирования.

Важно помнить: когда строка нам больше не нужна, необходимо освободить её вручную с помощью `allocator.free`. В противном случае может возникнуть утечка памяти.

## Заключение
Срезы и строки в Zig являются мощными и гибкими инструментами, позволяющими эффективно работать с последовательностями данных и текстом. Понимание их особенностей и возможностей критически важно для написания эффективного и безопасного кода.

Ключевые моменты, которые следует запомнить:

1. Срезы представляют собой "вид" на последовательность элементов и содержат указатель на начало и длину.
2. Строки в Zig — это просто срезы константных байтов (`[]const u8`).
3. Для большинства операций со строками и срезами требуется аллокатор для управления памятью.
4. Zig предлагает sentinel срезы для совместимости с C-строками и другими API, требующими терминаторы.
5. Стандартная библиотека Zig предоставляет множество полезных функций для работы со строками и срезами.
