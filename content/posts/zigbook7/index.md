---
title: Управление потоком
date: 2025-02-24 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
---

Предыдущая глава получилась у нас довольно сложная и объемная, поэтому давайте немного отдохнем от сложного погружения и рассмотрим в этой главе операторы управления потоком выполнения, а в следующей главе снова нырнем в язык и рассмотрми слайсы и строки в языке Zig.

## Операторы управления потоком
Операторы управления потоком в Zig наверняка покажутся вам знакомыми, однако их взаимодействие с некоторыми особенностями языка имеет нюансы. Но прежде чем перейти к рассмотрению различных операторов управления потоком, давайте познакомимся с блоками кода.

### Блоки
В Zig блоки кода создаются с помощью фигурных скобок `{}`. Блок представляет собой группу выражений или операторов, заключённых в эти скобки. Все выражения внутри одного блока принадлежат к единой области видимости.

Проще говоря, блок определяет границы области видимости внутри кода. Все переменные и объекты, объявленные внутри блока, доступны только в его пределах и недоступны за его границами. Таким образом, блоки помогают ограничивать область действия объектов, определённых в коде.

Блоки встречаются в разных конструкциях Zig:
* Тело функции – классический пример блока.
* Операторы if, for, while, switch – их код также находится внутри блоков.
* Блок созданный использование фигурных скобок `{}`.

Вы можете создавать блоки внутри блоков с несколькими уровнями вложенности. Вы также можете (если хотите) дать метку определенному блоку с помощью двоеточия (:). Просто напишите метку: прежде чем открыть пару фигурных скобок, которые ограничивают ваш блок. Когда вы помечаете блок в Zig, вы можете использовать ключевое слово `break`, чтобы вернуть значение из этого блока, как если бы это было тело функции. Вы просто пишете ключевое слово `break`, за которым следует метка блока в формате :label и выражение, которое определяет значение, которое вы хотите вернуть.

Давайте рассмотрим пример определения блока:

```zig
const std = @import("std");

pub fn main() void {
    const result = my_block: {
        if (true) break :my_block 42;
        break :my_block 0;
    };

    std.debug.print("Результат: {}\n", .{result});
}
```

Здесь блок my_block используется как выражение. Оператор break :my_block 42; завершает блок и возвращает значение 42, как если бы это была функция. Таким образом блоки можно использовать, если вам необходимо провести сложную инициализацию переменной, но Вы не хотите "захламлять" код основной функции переменными.

### Оператор `if`
Оператор `if/else` управляет выполнением кода в зависимости от заданного условия. Этот механизм, называемый условным управлением потоком или управлением выбором, позволяет программе либо выполнить определённый блок команд, либо пропустить его на основе логического выражения. В программировании и компьютерных науках этот процесс также часто называют «ветвлением». Проще говоря, `if/else` использует результат логической проверки, чтобы определить, следует ли выполнять конкретный фрагмент кода. В отличие от других языков, в Zig наличие круглых скобок вокруг выражения является обязательным. Также, так как Zig не приводит неявно типы, то выражение в круглых скобках должно быть явно приведено к типу `bool`.

Оператор `if` в Zig имеет следующий синтаксис:

```zig
if (condition) {
    // код, который выполняется, если условие истинно
} else if (another_condition) {
    // код, который выполняется, если второе условие истинно
} else {
    // код, который выполняется, если все условия ложны
}
```

В Zig оператор `if/else` записывается с использованием ключевых слов `if` и `else`. Сначала идет `if`, за которым следует логическое выражение в круглых скобках. Затем открываются фигурные скобки, внутри которых находится код, который выполняется, если условие истинно (true).

После основного условия можно добавить дополнительные проверки, которые будут выполняться, если предыдущее выражение оказалось ложным. Для этого используется ключевое слово `else if`, за которым следует новое условие в круглых скобках и блок кода в фигурных скобках, который выполняется при его истинности. Также можно просто добавить `else` с фигурными скобками, содержащими код, который выполнится, если ни одно из предыдущих условий не оказалось верным.

Давайте рассмотрим пример использования оператора `if`:

```zig
const std = @import("std");

pub fn main() void {
    const number: i32 = -5;

    if (number > 0) {
        std.debug.print("Число {} положительное\n", .{number});
    } else if (number < 0) {
        std.debug.print("Число {} отрицательное\n", .{number});
    } else {
        std.debug.print("Число равно нулю\n", .{});
    }
}
```

В данном примере мы проверяем значение переменной `number` и выводим соответствующее сообщение в зависимости от ее знака. Если `number` больше нуля, то выводится сообщение "Число {number} положительное". Если `number` меньше нуля, то выводится сообщение "Число {number} отрицательное". Если `number` равен нулю, то выводится сообщение "Число равно нулю".

В Zig, в отличие от многих других языков, оператор `if` может возвращать значение. Это особенно полезно, когда нужно присвоить переменной значение в зависимости от условий.

```zig
const should_drive = if (speed > 10) {
  true
} else {
  false
};
```

В случае, если в блоках вашего оператора `if/elseif/else` всего одна инструкция, мы можем сделать наш условный оператор еще короче, убрав фигурные скобки:

```zig
const should_drive = if (speed > 10) true else false;
```

### Оператор switch
Оператор `switch` в Zig позволяет проверять значение переменной и выполнять соответствующий код в зависимости от совпадения. Это удобный способ обработки множества вариантов без громоздких `if/else if` конструкций. Оператор `switch` в Zig похож на аналогичный оператор в Rust тем, что он требует указания всех возможных вариантов. Вы также можете использовать диапазоны или перечисления в операторе `switch`.

Базовый синтаксис оператора switch в Zig выглядит следующим образом:

```zig
switch (выражение) {
    значение1 => {
        // Действия, если выражение равно значению1
    },
    значение2 => {
        // Действия, если выражение равно значению2
    },
    // ...
    else => {
        // Действия по умолчанию, если ни одно из значений не совпало
    },
}
```

В данном примере:
* выражение — это переменная или выражение, значение которого будет сравниваться с различными вариантами.
* значение1, значение2, ... — это возможные значения, с которыми сравнивается выражение.
* else — это ветка, которая выполняется, если ни одно из значений не совпало с выражением.

В Zig оператор `switch` должен быть полным, то есть все возможные значения выражения должны быть обработаны. Если вы используете `switch` с перечислением (enum), компилятор потребует, чтобы все варианты перечисления были явно обработаны, либо чтобы была указана ветка `else`.

Рассмотрим простой пример, где мы используем `switch` для обработки различных значений целочисленной переменной:

```zig
const std = @import("std");

pub fn main() void {
    const number = 2;

    switch (number) {
        1 => {
            std.debug.print("Число равно 1\n", .{});
        },
        2, 3 => {
            std.debug.print("Число равно 2 или 3\n", .{});
        },
        4 => {
            std.debug.print("Число равно 4\n", .{});
        },
        else => {
            std.debug.print("Число не равно 1, 2, 3 или 4\n", .{});
        },
    }
}
```

Пример использования с диапазонами. При использовании диапазонов, в заданный диапазо включаются обе границы:

```zig
const number = 5;

switch (number) {
    1...3 => {
        std.debug.print("Число между 1 и 3\n", .{});
    },
    4...6 => |n| {
        std.debug.print("Число {} между 4 и 6\n", .{n});
    },
    else => {
        std.debug.print("Число вне диапазонов\n", .{});
    },
}
```

Для того, чтобы при использовании диапазано получить конкретное число, можно использовать оператор `|n|`. В данном примере если наше число будет в диапазоне от 4 до 6, то мы получим конкретное число, которое будет присвоено переменной `n`. Это позволяет использовать фактическое значение внутри блока кода.

```zig
const number = 5;

switch (number) {
    1...3 => {
        std.debug.print("Число между 1 и 3\n", .{});
    },
    4...6 => |n| {
        std.debug.print("Число {} между 4 и 6\n", .{n});
    },
    else => {
        std.debug.print("Число вне диапазонов\n", .{});
    },
}
```

Кроме перечисленных вариантов, в Zig в операторе `switch` мы также можем использовать значение, вычисляемое на этапе компиляции:

```zig
const number = 2;

switch (number) {
    blk: {
        const a = 10;
        const b = 8;
        break :blk a - b;
    } => {
        std.debug.print("Число равно 2\n", .{});
    },
    else => {
        std.debug.print("Число вне диапазонов\n", .{});
    },
}
```

В данном примере мы используем блок для вычисления значения, с которым будет сравниваться наша переменная при выполнении оператора `switch`. В этом случае значение блока равно 2 (результат выражения 10 - 8), что соответствует нашей переменной.

Оператор `switch` как и оператор `if` может возвращать значение, что позволяет использовать его для инициализации переменных:

```zig
const level: u8 = 4;
const log_level = switch (level) {
    1 => "Error",
    2 => "Warning",
    3 => "Info",
    4 => "Debug",
    5 => "Trace",
    else => unreachable(),
};
try stdout.print("{s}\n", .{log_level});
```

Когда мы будем рассматривать перечисления, мы увидим еще варианты как можно использовать оператор `switch`.

### Оператор while
Оператор `while` в Zig с одной стороны очень похож на то, что Вы встречали в других языках, с другой стороны у него есть ряд особенностей, специфичных для языка Zig. В общем виде оператор `while` в Zig имеет следующий синтаксис:

```zig
while (condition) {
    // тело цикла
}
```

Так же как и в предыдущих операторах, наличие круглых скобок в операторе обязательно и значение внутри круглых скобок должно быть типа `bool`. Для того, чтобы прервать цикл, мы можем использовать два оператора - `break` и `continue`. Оператор `continue` позволяет пропустить оставшуюся часть тела цикла и перейти к следующей итерации, а оператор `break` позволяет прервать цикл и перейти к следующей инструкции после цикла. Обычно оператор `while`используется примерно в следующей форме:

```zig
var i: u8 = 1;
while (i < 5) {
    try stdout.print("{d} | ", .{i});
    i += 1;
}
```

 данном примере мы проводим инкремент переменной `i` на 1 на каждой итерации цикла, а в операторе `while` мы проверяем наше условие. В таких простых случаях оператор `while` поддерживает дополнительный синтаксис, позволяющий перенести изменение итератора цикла в конструкцию `while`:

```zig
var i: u8 = 1;
while (i < 5) : (i += 1) {
    try stdout.print("{d} | ", .{i});
}
```

В этом коде после выполнения очередного цикла оператора `while` сначало будет выполнен оператор, определенный после `:`, а затем оператор `while` проверит условие и если оно истинно, то цикл будет продолжен, иначе цикл будет прерван.

При использовании вложенных циклов `while` может возникнуть необходимость прервать или перейти к следующей итерации не текущего, а внешнего цикла. В этом случае можно использовать метки для циклов и применять операторы `break` и `continue` с указанием соответствующей метки. Рассмотрим пример:

```zig
const std = @import("std");

pub fn main() void {
    outer: while (true) {
        var i: u8 = 0;
        while (i < 5) : (i += 1) {
            if (i == 3) break :outer; // выход из внешнего цикла
            std.debug.print("{} ", .{i});
        }
        std.debug.print("Эта строка не будет выведена\n", .{});
    }
    std.debug.print("\nВыход из обоих циклов\n", .{});
}
```

Также как операторы `if` и `switch` оператор `while` поддерживает возвращение значения и цикла, с использованием оператора `break`:

```zig
var i: u8 = 1;
const expected = 3;
const found = while (i < 5) : (i += 1) {
    if (i == expected) break true;
} else false;

std.debug.print("Found: {}\n", .{found});
```

Одна из интересных особбеностей оператора `while` это использование его с опциональным типом `?T`. Например у нас может быть код, который итерируется по массиву пока не найдет нулевое значение, и для проверки условия мы используем функцию:

```zig
const std = @import("std");

var index: usize = 0;
var array = [_]u8{ 1, 2, 3, 4, 5, 0, 6, 7, 8 };

fn checkElement() ?usize {
    return if (array[index] == 0) null else blk: {
        index += 1;
        break :blk index;
    };
}

pub fn main() !void {
    while (checkElement()) |i| {
        std.debug.print("{d} | ", .{i});
    }
}
```

В этом примере функция `checkElement()` возвращает значение типа `?usize`, то есть либо индекс элемента, либо `null`, если найден элемент со значением 0. В цикле `while` мы используем синтаксис `|i|` для разворачивания опционального значения. Если функция возвращает числовое значение, оно присваивается переменной `i` и используется внутри цикла. Если функция возвращает `null`, цикл завершается.

Этот код выведет индексы элементов массива от 1 до 5, а затем прекратит работу, когда функция вернет `null` при обнаружении элемента со значением 0 на позиции с индексом 5.

### Оператор for
Оператор `for` в Zig используется для итерации по элементам коллекций, таких как массивы, слайсы или другие структуры данных, поддерживающие итерирование. В отличие от многих других языков, `for` в Zig имеет более строгий и предсказуемый синтаксис, что делает код более безопасным и понятным.

Базовый синтаксис оператора `for` в Zig выглядит следующим образом:

```zig
for (collection) |value, index| {
    // код, который выполняется для каждого элемента
}
```

Здесь:
- `collection` - это коллекция, по которой происходит итерация (массив, слайс и т.д.)
- `value` - значение текущего элемента коллекции
- `index` - индекс текущего элемента (необязательный параметр)

Рассмотрим простой пример использования оператора `for` для итерации по массиву:

```zig
const std = @import("std");

pub fn main() void {
    const numbers = [_]i32{ 1, 2, 3, 4, 5 };

    for (numbers) |number| {
        std.debug.print("{} ", .{number});
    }
    std.debug.print("\n", .{});

    // С использованием индекса
    for (numbers) |number, i| {
        std.debug.print("Элемент [{}] = {}\n", .{i, number});
    }
}
```

В первом цикле мы просто выводим каждое число из массива. Во втором цикле мы также используем индекс элемента, что позволяет нам отображать позицию элемента в массиве.

Если вам нужен только индекс, но не значение элемента, можно использовать символ подчеркивания `_` для игнорирования значения:

```zig
for (numbers) |_, i| {
    std.debug.print("Индекс: {}\n", .{i});
}
```

Также в Zig есть возможность итерирования по нескольким коллекциям одновременно с помощью многоколлекционного `for`:

```zig
const names = [_][]const u8{ "Алиса", "Боб", "Чарли" };
const ages = [_]u8{ 25, 30, 35 };

for (names, ages) |name, age| {
    std.debug.print("{s} - {} лет\n", .{name, age});
}
```

Этот код выведет имя и возраст каждого человека из соответствующих массивов. Обратите внимание, что длины массивов должны совпадать, иначе компилятор выдаст ошибку.

Как и другие операторы управления потоком в Zig, `for` поддерживает операторы `break` и `continue` для раннего выхода из цикла или перехода к следующей итерации:

```zig
const numbers = [_]i32{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

for (numbers) |number| {
    if (number % 2 == 0) continue; // Пропускаем четные числа
    if (number > 7) break; // Выходим из цикла, если число больше 7
    std.debug.print("{} ", .{number});
}
// Выведет: 1 3 5 7
```

Оператор `for` также может использоваться с метками, что позволяет управлять вложенными циклами:

```zig
outer: for (rows) |row| {
    for (row) |cell| {
        if (cell == target) {
            std.debug.print("Найдено!\n", .{});
            break :outer; // Выходим из внешнего цикла
        }
    }
}
```

И наконец, как и другие конструкции управления потоком в Zig, `for` может возвращать значение с помощью оператора `break`:

```zig
const found_index = for (numbers) |number, i| {
    if (number == target) break i;
} else unreachable; // Выполняется, если break не был вызван
```

Этот код ищет индекс элемента target в массиве numbers. Если элемент найден, цикл возвращает его индекс с помощью break i. Блок else выполняется только если цикл завершился естественным путем, то есть если элемент не был найден.

## Заключение

В этой главе мы рассмотрели основные конструкции управления потоком в языке Zig: блоки кода, условные операторы `if` и `switch`, а также циклы `while` и `for`. Мы увидели, что эти конструкции в Zig имеют некоторые особенности и расширенные возможности по сравнению с другими языками программирования:

1. Блоки кода могут иметь метки и возвращать значения, что делает их похожими на маленькие функции.
2. Условные операторы `if` и `switch` также могут возвращать значения, что позволяет писать более компактный и выразительный код.
3. Циклы `while` и `for` поддерживают дополнительные конструкции, такие как постусловие или работа с опциональными типами.
4. Все конструкции управления потоком могут быть вложенными и поддерживают использование меток для более сложного управления выполнением.

Понимание этих конструкций и их особенностей в Zig поможет вам писать более эффективный, безопасный и читаемый код. В следующей главе мы рассмотрим слайсы и строки в языке Zig.
