---
title: Управление потоком
date: 2025-02-24 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
---

Предыдущая глава получилась у нас довольно сложная и объемная, поэтому давайте немного отдохнем от сложного погружения и рассмотрим в этой главе операторы управления потоком выполнения, а в следующей главе снова нырнем в язык и рассмотрми слайсы и строки в языке Zig.

## Операторы управления потоком
Операторы управления потоком в Zig наверняка покажутся вам знакомыми, однако их взаимодействие с некоторыми особенностями языка имеет нюансы. Но прежде чем перейти к рассмотрению различных операторов управления потоком, давайте познакомимся с блоками кода.

### Блоки
В Zig блоки кода создаются с помощью фигурных скобок `{}`. Блок представляет собой группу выражений или операторов, заключённых в эти скобки. Все выражения внутри одного блока принадлежат к единой области видимости.

Проще говоря, блок определяет границы области видимости внутри кода. Все переменные и объекты, объявленные внутри блока, доступны только в его пределах и недоступны за его границами. Таким образом, блоки помогают ограничивать область действия объектов, определённых в коде.

Блоки встречаются в разных конструкциях Zig:
* Тело функции – классический пример блока.
* Операторы if, for, while – их код также находится внутри блоков.
* Любая другая структура с {} – например, switch

Вы можете создавать блоки внутри блоков с несколькими уровнями вложенности. Вы также можете (если хотите) дать метку определенному блоку с помощью двоеточия (:). Просто напишите метку: прежде чем открыть пару фигурных скобок, которые ограничивают ваш блок. Когда вы помечаете блок в Zig, вы можете использовать ключевое слово `break`, чтобы вернуть значение из этого блока, как если бы это было тело функции. Вы просто пишете ключевое слово `break`, за которым следует метка блока в формате :label и выражение, которое определяет значение, которое вы хотите вернуть.

Давайте рассмотрим пример определения блока:

```zig
const std = @import("std");

pub fn main() void {
    const result = my_block: {
        if (true) break :my_block 42;
        break :my_block 0;
    };

    std.debug.print("Результат: {}\n", .{result});
}
```

Здесь блок my_block используется как выражение. Оператор break :my_block 42; завершает блок и возвращает значение 42, как если бы это была функция.

### Оператор `if`
Оператор `if/else` управляет выполнением кода в зависимости от заданного условия. Этот механизм, называемый условным управлением потоком или управлением выбором, позволяет программе либо выполнить определённый блок команд, либо пропустить его на основе логического выражения. В программировании и компьютерных науках этот процесс также часто называют «ветвлением». Проще говоря, `if/else` использует результат логической проверки, чтобы определить, следует ли выполнять конкретный фрагмент кода.

Оператор `if` в Zig имеет следующий синтаксис:

```zig
if (condition) {
    // код, который выполняется, если условие истинно
} else if (another_condition) {
    // код, который выполняется, если второе условие истинно
} else {
    // код, который выполняется, если все условия ложны
}
```

В Zig оператор `if/else` записывается с использованием ключевых слов `if` и `else`. Сначала идет `if`, за которым следует логическое выражение в круглых скобках. Затем открываются фигурные скобки, внутри которых находится код, который выполняется, если условие истинно (true).

После основного условия можно добавить дополнительные проверки, которые будут выполняться, если предыдущее выражение оказалось ложным. Для этого используется ключевое слово `else if`, за которым следует новое условие в круглых скобках и блок кода в фигурных скобках, который выполняется при его истинности. Также можно просто добавить `else` с фигурными скобками, содержащими код, который выполнится, если ни одно из предыдущих условий не оказалось верным.

Давайте рассмотрим пример использования оператора `if`:

```zig
const std = @import("std");

pub fn main() void {
    const number: i32 = -5;

    if (number > 0) {
        std.debug.print("Число {} положительное\n", .{number});
    } else if (number < 0) {
        std.debug.print("Число {} отрицательное\n", .{number});
    } else {
        std.debug.print("Число равно нулю\n", .{});
    }
}
```

В данном примере мы проверяем значение переменной `number` и выводим соответствующее сообщение в зависимости от ее знака. Если `number` больше нуля, то выводится сообщение "Число {number} положительное". Если `number` меньше нуля, то выводится сообщение "Число {number} отрицательное". Если `number` равен нулю, то выводится сообщение "Число равно нулю".

В Zig, в отличие от многих других языков, оператор `if` может возвращать значение. Это особенно полезно, когда нужно присвоить переменной значение в зависимости от условий.

```zig
const should_drive = if (speed > 10) {
  true
} else {
  false
};
```

В случае, если в блоках вашего оператора `if/elseif/else` всего одна инструкция, мы можем сделать наш условный оператор еще короче, убрав фигурные скобки:

```zig
const should_drive = if (speed > 10) true else false;
```

### Оператор switch
Оператор `switch` в Zig позволяет проверять значение переменной и выполнять соответствующий код в зависимости от совпадения. Это удобный способ обработки множества вариантов без громоздких `if/else if` конструкций. Оператор `switch` в Zig похож на аналогичный оператор в Rust тем, что он требует указания всех возможных вариантов. Вы также можете использовать диапазоны или перечисления в операторе `switch`.

Базовый синтаксис оператора switch в Zig выглядит следующим образом:

```zig
switch (выражение) {
    значение1 => {
        // Действия, если выражение равно значению1
    },
    значение2 => {
        // Действия, если выражение равно значению2
    },
    // ...
    else => {
        // Действия по умолчанию, если ни одно из значений не совпало
    },
}
```

В данном примере:
* выражение — это переменная или выражение, значение которого будет сравниваться с различными вариантами.
* значение1, значение2, ... — это возможные значения, с которыми сравнивается выражение.
* else — это ветка, которая выполняется, если ни одно из значений не совпало с выражением.

В Zig оператор `switch` должен быть полным, то есть все возможные значения выражения должны быть обработаны. Если вы используете `switch` с перечислением (enum), компилятор потребует, чтобы все варианты перечисления были явно обработаны, либо чтобы была указана ветка `else`.

Рассмотрим простой пример, где мы используем `switch` для обработки различных значений целочисленной переменной:

```zig
const std = @import("std");

pub fn main() void {
    const number = 2;

    switch (number) {
        1 => {
            std.debug.print("Число равно 1\n", .{});
        },
        2 => {
            std.debug.print("Число равно 2\n", .{});
        },
        3 => {
            std.debug.print("Число равно 3\n", .{});
        },
        else => {
            std.debug.print("Число не равно 1, 2 или 3\n", .{});
        },
    }
}
```

Пример использования с диапазонами:

```zig
const number = 5;

switch (number) {
    1...3 => {
        std.debug.print("Число между 1 и 3\n", .{});
    },
    4...6 => {
        std.debug.print("Число между 4 и 6\n", .{});
    },
    else => {
        std.debug.print("Число вне диапазонов\n", .{});
    },
}
```

Оператор `switch` как и оператор `if` может возвращать значение, что позволяет использовать его для инициализации переменных:

```zig
const level: u8 = 4;
const log_level = switch (level) {
    1 => "Error",
    2 => "Warning",
    3 => "Info",
    4 => "Debug",
    5 => "Trace",
    else => unreachable(),
};
try stdout.print("{s}\n", .{log_level});
```
