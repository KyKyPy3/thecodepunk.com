---
title: Интерфейсы
date: 2025-03-22 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - interface
---

В отличие от таких языков как Go или Java, в Zig нет встроенной поддержки интерфейсов. Однако это не означает, что Zig нет возможности использовать интерфейсы. В Zig интерфейсы реализуются с помощью структур и метапрограммирования. Прежде чем мы рассмотрим, как это сделать, давайте разберемся зачем нужны интерфейсы и как они реализуются в других языках программирования.

## Зачем нужны интерфейсы
Интерфейсы это один из основных строительных блоков в программировании для реализации большинства архитектурных шаблонов, таких как Clean Architecture, Domain-Driven Design и другие. Они позволяют разделить ваше приложение на отдельные компоненты и ослабить связи между этими компонентами. Это позволяет упростить разработку, тестирование и вносить изменения в ваш проект, завтрагивая только те компоненты, которые действительно нуждаются в изменении.

Давайте рассмотрим использование интерфейсов в языке Go. Интерфейсы в Go определяются с помощью ключевого слова `interface` и содержат только сигнатуры методов, которые должны быть реализованы в структуре для соответствия этому интерфейсу.

```go
type Drawable interface {
    Draw()
}

type Circle struct{}
func (c Circle) Draw() {
    fmt.Println("Рисуем круг")
}

type Square struct{}
func (s Square) Draw() {
    fmt.Println("Рисуем квадрат")
}

type Triangle struct{}
func (t Triangle) Draw() {
    fmt.Println("Рисуем треугольник")
}

func drawElements(elements []Drawable) {
    for _, element := range elements {
        element.Draw()
    }
}

fn main() {
	// Создаем элементы и отправляем на отрисовку
	drawElements([]Drawable{Circle{}, Square{}, Triangle{}})
}
```

В данном примере мы используем интерфейс `Drawable` для отрисовки элементов на экране. Наш интерфейс определяет метод `draw()`, который должны реализовать все структуры, поддерживающие этот интерфейс.

Мы создаём три конкретные фигуры: круг, квадрат и треугольник, каждая из которых реализует метод `draw()`, соответствующий нашему интерфейсу. В языке Go не нужно явно указывать, что структура реализует интерфейс — достаточно просто реализовать необходимые методы и использовать структуру там, где ожидается интерфейс. Компилятор сам проверит во время компиляции, что структура реализует все методы интерфейса.

В результате мы получаем возможность создать универсальный метод отрисовки фигур `drawElements`, который может отрисовывать любую фигуру, поддерживающую интерфейс `Drawable`. Такому методу неважно, какую именно фигуру мы передаём — он просто ожидает, что фигура реализует интерфейс отрисовки. Это позволяет:

* Писать более гибкий код
* Легко расширять набор поддерживаемых фигур
* Не изменять основную логику отрисовки при добавлении новых типов фигур

Это, конечно, очень упрощённый пример. В реальных проектах интерфейсы применяются для более сложных сценариев. Например, вы можете реализовать интерфейс работы с базой данных и легко поддерживать разные типы СУБД, просто изменяя реализацию этого интерфейса, не затрагивая основной код бизнес-логики.

Такой подход сохраняет архитектурную целостность приложения и упрощает его масштабирование. В целом применений интерфейсов в коде любого проекта достаточно много, и скорее всего вам они точно понадобятся чтобы сделать ваш код более гибким и масштабируемым.

## Реализация интерфейсов
Zig не предоставляет встроенной поддержки интерфейсов на уровне синтаксиса языка, поэтому вам придётся реализовывать эту функциональность самостоятельно. Однако не стоит беспокоиться — благодаря мощным возможностям метапрограммирования в Zig, реализация интерфейсов не представляет особой сложности.

Прежде чем перейти к реализации интерфейсов в Zig, давайте разберёмся, как они работают в языках с нативной поддержкой интерфейсов. Рассмотрим пример на Go: основная "магия" происходит в методе `drawElements`, который принимает параметры интерфейсного типа, хотя мы передаём туда конкретные структуры.

Как Go понимает, как правильно отрисовать каждую фигуру? Согласно документации Go, интерфейс представляет собой "двойной" указатель, состоящий из:
* Указателя на конкретную структуру
* Указателя на таблицу методов

Подобная реализация с двумя указателями встречается практически во всех языках программирования. Основные различия между реализациями заключаются в том, когда формируется список методов для интерфейса — во время компиляции или в процессе выполнения программы. Вот как это примерно выглядит внутри языков поддерживающих интерфейсы:

{{< figure src="interface_dark.svg" class="post-image-dark small">}}
{{< figure src="interface_light.svg" class="post-image-light small">}}

Как мы видим, для того чтобы нам реализовать поддержку интерфейсов в языке Zig, нам необходимо создать такой "двойной" указатель, который будет содержать указатель на конкретную структуру и указатель на таблицу методов. Давайте попробуем это реализовать в Zig.

## Интерфейсы в Zig
Для того чтобы реализовать интерфейс в Zig нужно рассмотреть два момента - описание самого интерфейса и поддержка интерфейса в конкретной структуре. Давайте начнем с описания нашего интерфейса и попробуем реализовать стандартный интерфейс `Write`:

```zig
const Write = struct {
  ptr: *anyopaque,
  writeFn: *const fn (ptr: *anyopaque, data: []const u8) anyerror!usize,

  fn write(self: Write, data: []const u8) !usize {
    return self.writeFn(self.ptr, data);
  }
};
```

Реализация интерфейса `Write` получилась достаточно лаконичной. Мы создали структуру, которая содержит:
* Указатель на данные (ptr)
* Функцию для их записи (writeFn)
* Метод-обёртку для удобного вызова (write)

Вы можете спросить: "А где же VTable, которую мы обсуждали ранее"? В текущей реализации для упрощения мы встроили её прямо в структуру, но позже рассмотрим вариант с вынесенной VTable. Несмотря на кажущуюся простоту, в этом коде есть несколько важных нюансов, которые требуют пояснения.

Первое, что сразу обращает на себя внимание — использование указателя на `anyopaque` вместо конкретного типа. Это не случайно. `anyopaque` в Zig означает "неизвестный тип", что позволяет нашему интерфейсу работать с любыми данными. Если бы мы указывали тут конкретный тип, то наш интерфейс не смог бы поддерживать работу с разными структурами.

Но почему именно указатель на `anyopaque`, а не просто `anyopaque`? Всё дело в требованиях Zig к размерам типов. Если бы мы хранили `anyopaque` напрямую, компилятор не смог бы определить размер структуры — ведь он варьируется в зависимости от типа данных. Указатель же всегда имеет фиксированный размер (usize), известный при компиляции. Это даёт нам необходимую гибкость, сохраняя безопасность типов.

Второй момент, это то как мы обьявляем функцию для записи данных. Она принимает указатель на `anyopaque` и данные. И это на самом деле проблема, которую мы осознаем, если попытаемся теперь реализовать наш интерфейс для нашей структуры. Давайте рассмотрим как это могло бы выглядеть:

```zig
const File = struct {
  fd: os.fd_t,

  fn write(ptr: *anyopaque, data: []const u8) !void {
    ...
  }

  fn writer(self: *File) Write {
    return .{
      .ptr = self,
      .writeFn = write,
    };
  }
};
```

Мы видим, что для типа данных `File` реализован метод `writer` возвращающий интерфейс `Write`. Поскольку Zig не предоставляет встроенной поддержки интерфейсов на уровне компилятора, преобразование типов приходится выполнять вручную.

Этот подход уже знаком нам по работе с аллокаторами. Например, при создании аллокатора через `std.heap.DebugAllocator(.{}).init()` мы затем вызывали метод `allocator()`, который возвращал интерфейс `std.mem.Allocator`. В текущем примере мы применяем аналогичный принцип для получения интерфейса `Write`.

Остался теперь самый сложный момент - что нам делать в нашем методе `write`. На вход нашего метода мы получаем `*anyopaque`, так как мы так определеили в нашем интерфейсе. Но нам то надо работать с указателем на наш тип `File`. И тут как раз нам помогут возможности метапрограммирования в Zig. Давайте рассмотрим как мы можем решить нашу проблему:


```zig
const File = struct {
  fd: os.fd_t,

  fn write(ptr: *anyopaque, data: []const u8) !usize {
    const self: *File = @ptrCast(@alignCast(ptr));
    return try std.fs.File.write(self.fd, data);
  }

  fn writer(self: *File) Write {
    return .{
      .ptr = self,
      .writeFn = write,
    };
  }
};
```

Рассмотрим подробнее работу функции `write`. Когда мы получаем указатель на `anyopaque`, физически в памяти находится указатель на структуру `File`, но компилятор об этом не знает - использование `anyopaque` скрывает информацию о реальном типе. Чтобы восстановить эту информацию, мы применяем знакомую функцию `@ptrCast`, преобразующую указатель из одного типа в другой.

Но зачем нужен `@alignCast`? Дело в том, что `anyopaque` имеет выравнивание 1 (так как может представлять любой тип), тогда как структура `File` требует выравнивания 4. Функция `@alignCast` решает эту проблему, преобразуя указатель с выравниванием 1 в указатель с выравниванием 4.

Таким образом, в реализации `write` мы последовательно используем:
1. `@alignCast` для корректировки выравнивания
2. `@ptrCast` для восстановления информации о типе

Это позволяет безопасно преобразовать `anyopaque` обратно в `File`, восстановив его тип и выравнивание.

В целом наша реализация готова и даже работает, но у нее есть один существенный недостаток - мы не можем использовать метод `write` напрямую, так как он ожидает на вход не указатель на `File`, а указатель на `anyopaque`. Мы конечно можем передать туда `File` и наша реализация восстановит тип, но мы теряем проверку типов на этапе компилирования, а это не очень хорошо. И мы мможем исправить эту проблему используя все теже возможности рефлексии в Zig. Но конечно решение нашей проблемы потребует изменение интерфейса `Write`:

```zig
const Write = struct {
  ptr: *anyopaque,
  writeFn: *const fn (ptr: *anyopaque, data: []const u8) anyerror!usize,

  fn init(ptr: anytype) Write {
    const T = @TypeOf(ptr);
    const ptr_info = @typeInfo(T);

    const wrap = struct {
      pub fn write(pointer: *anyopaque, data: []const u8) anyerror!usize {
        const self: T = @ptrCast(@alignCast(pointer));
        return ptr_info.Pointer.child.writeAll(self, data);
      }
    };

    return .{
      .ptr = ptr,
      .writeFn = wrap.write,
    };
  }

  pub fn write(self: Write, data: []const u8) !usize {
    return self.writeFn(self.ptr, data);
  }
};
```

Как мы видим мы добавили новую функцию `init` в которой и заключены все наши изменения. Функция `init` на вход принимает всего один параметр `anytype` - любой тип. Дальше используя уже знакомые нам функции рифлексии `@TypeOf` и `@typeInfo` мы получаем информацию о конкретном типе `T` из нашего универсального типа `anytype`. Дальше все довольно просто - мы создаем замыкание `wrap`, используя анонимную структуру, где реализуем наш метод `write`, в котором мы передаем в конкретную реализацию уже не универсальный тип `*anyopaque`, а указатель на конкретный тип `*T`. Таким образом мы избавляемся от проблемы что наши методы в конкретной реализации работали с типом `anyopaque` и теперь мы можем вызвать их как при работе через интерфейс, так и без.
