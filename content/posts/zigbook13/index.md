---
title: Интерфейсы
date: 2025-03-22 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
  - interface
---

В отличие от таких языков как Go или Java, в Zig нет встроенной поддержки интерфейсов. Однако это не означает, что Zig нет возможности использовать интерфейсы. В Zig интерфейсы реализуются с помощью структур и метапрограммирования. Прежде чем мы рассмотрим, как это сделать, давайте разберемся зачем нужны интерфейсы и как они реализуются в других языках программирования.

## Зачем нужны интерфейсы
Интерфейсы это один из основных строительных блоков в программировании для реализации большинства архитектурных шаблонов, таких как Clean Architecture, Domain-Driven Design и другие. Они позволяют разделить ваше приложение на отдельные компоненты и ослабить связи между этими компонентами. Это позволяет упростить разработку, тестирование и вносить изменения в ваш проект, завтрагивая только те компоненты, которые действительно нуждаются в изменении.

Давайте рассмотрим использование интерфейсов в языке Go. Интерфейсы в Go определяются с помощью ключевого слова `interface` и содержат только сигнатуры методов, которые должны быть реализованы в структуре для соответствия этому интерфейсу.

```go
type Drawable interface {
    Draw()
}

type Circle struct{}
func (c Circle) Draw() {
    fmt.Println("Рисуем круг")
}

type Square struct{}
func (s Square) Draw() {
    fmt.Println("Рисуем квадрат")
}

type Triangle struct{}
func (t Triangle) Draw() {
    fmt.Println("Рисуем треугольник")
}

func drawElements(elements []Drawable) {
    for _, element := range elements {
        element.Draw()
    }
}

fn main() {
	// Создаем элементы и отправляем на отрисовку
	drawElements([]Drawable{Circle{}, Square{}, Triangle{}})
}
```

В данном примере мы используем интерфейс `Drawable` для отрисовки элементов на экране. Наш интерфейс определяет метод `draw()`, который должны реализовать все структуры, поддерживающие этот интерфейс.

Мы создаём три конкретные фигуры: круг, квадрат и треугольник, каждая из которых реализует метод `draw()`, соответствующий нашему интерфейсу. В языке Go не нужно явно указывать, что структура реализует интерфейс — достаточно просто реализовать необходимые методы и использовать структуру там, где ожидается интерфейс. Компилятор сам проверит во время компиляции, что структура реализует все методы интерфейса.

В результате мы получаем возможность создать универсальный метод отрисовки фигур `drawElements`, который может отрисовывать любую фигуру, поддерживающую интерфейс `Drawable`. Такому методу неважно, какую именно фигуру мы передаём — он просто ожидает, что фигура реализует интерфейс отрисовки. Это позволяет:

* Писать более гибкий код
* Легко расширять набор поддерживаемых фигур
* Не изменять основную логику отрисовки при добавлении новых типов фигур

Это, конечно, очень упрощённый пример. В реальных проектах интерфейсы применяются для более сложных сценариев. Например, вы можете реализовать интерфейс работы с базой данных и легко поддерживать разные типы СУБД, просто изменяя реализацию этого интерфейса, не затрагивая основной код бизнес-логики.

Такой подход сохраняет архитектурную целостность приложения и упрощает его масштабирование. В целом применений интерфейсов в коде любого проекта достаточно много, и скорее всего вам они точно понадобятся чтобы сделать ваш код более гибким и масштабируемым.

## Реализация интерфейсов
Zig не предоставляет встроенной поддержки интерфейсов на уровне синтаксиса языка, поэтому вам придётся реализовывать эту функциональность самостоятельно. Однако не стоит беспокоиться — благодаря мощным возможностям метапрограммирования в Zig, реализация интерфейсов не представляет особой сложности.

Прежде чем перейти к реализации интерфейсов в Zig, давайте разберёмся, как они работают в языках с нативной поддержкой интерфейсов. Рассмотрим пример на Go: основная "магия" происходит в методе `drawElements`, который принимает параметры интерфейсного типа, хотя мы передаём туда конкретные структуры.

Как Go понимает, как правильно отрисовать каждую фигуру? Согласно документации Go, интерфейс представляет собой "двойной" указатель, состоящий из:
* Указателя на конкретную структуру
* Указателя на таблицу методов

Подобная реализация с двумя указателями встречается практически во всех языках программирования. Основные различия между реализациями заключаются в том, когда формируется список методов для интерфейса — во время компиляции или в процессе выполнения программы. Вот как это примерно выглядит внутри языков поддерживающих интерфейсы:

{{< figure src="interface_dark.svg" class="post-image-dark small">}}
{{< figure src="interface_light.svg" class="post-image-light small">}}

Как мы видим, для того чтобы нам реализовать поддержку интерфейсов в языке Zig, нам необходимо создать такой "двойной" указатель, который будет содержать указатель на конкретную структуру и указатель на таблицу методов. Давайте попробуем это реализовать в Zig.

## Интерфейсы в Zig
Для того чтобы реализовать интерфейс в Zig нужно рассмотреть два момента - описание самого интерфейса и поддержка интерфейса в конкретной структуре. Давайте начнем с описания нашего интерфейса. Давайте попробуем реализовать стандартный интерфейс Write:

```zig
const Write = struct {
  ptr: *anyopaque,
  writeFn: *const fn (ptr: *anyopaque, data: []const u8) anyerror!usize,

  fn write(self: Write, data: []const u8) !usize {
    return self.writeFn(self.ptr, data);
  }
};
```

Реализация интерфейса Write действительно получилась лаконичной. Мы создали структуру, содержащую указатель на данные и функцию для их записи, а затем добавили метод-обёртку для удобного вызова. Однако в коде есть несколько тонкостей, которые стоит пояснить.

Первое, что сразу обращает на себя внимание — использование указателя на anyopaque вместо конкретного типа. Это не случайно. anyopaque в Zig означает "неизвестный тип", что позволяет нашему интерфейсу работать с любыми данными.

Но почему именно указатель, а не значение? Всё дело в требованиях Zig к размерам типов. Если бы мы хранили anyopaque напрямую, компилятор не смог бы определить размер структуры — ведь он варьируется в зависимости от типа данных. Указатель же всегда имеет фиксированный размер (usize), известный при компиляции. Это даёт нам необходимую гибкость, сохраняя безопасность типов.
