---
title: Срезы и строки
date: 2025-02-28 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
---
Срезы в Zig — это мощный инструмент для работы с последовательностями элементов. Они представляют собой структуру данных, которая содержит указатель на начало последовательности и её длину. По сути, срезы можно рассматривать как "вид" на подмножество массива или области памяти. Эта концепция будет знакома разработчикам, которые работали с такими языками, как Rust или Go.

## Объявление и создание срезов

Тип среза в Zig обозначается как `[]T`, где `T` — это тип элементов. Например, `[]u8` представляет срез беззнаковых 8-битных целых чисел, а `[]const u8` — срез, элементы которого не могут быть изменены (что часто используется для строк).

Если Вы попробуете создать срез из массива или из части массива, но при этом границы вашего среза будут известны на этапе компиляции, то на самом деле вы создадите не срез, а просто указатель на массив. Давайте рассмотрим эти два сценария:

```zig
const std = @import("std");

pub fn main() void {
    // Исходный массив
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание среза всего массива
    const slice1 = &array;

    std.debug.print("Slice1 type: {}\n", .{@TypeOf(slice1)});

    // Создание среза части массива
    const slice2 = array[1..3];

    std.debug.print("Slice2 type: {}\n", .{@TypeOf(slice2)});
}
```

Этот код выведет следующее:

```
Slice1 type: *[5]i32
Slice2 type: *[2]i32
```

Как видно, в обоих случаях создаются указатели на массивы, а не срезы. Чтобы явно создать срез, нужно указать тип переменной как тип среза, либо чтобы параметры среза были не известны на этапе компиляции:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание среза элементов со 2-го по 4-й (индексы 1-3). Мы явно указываем тип среза
    const slice1: []i32 = array[1..4];

    std.debug.print("Slice1 type: {}\n", .{@TypeOf(slice1)});

    var start: usize = 1;
    var end: usize = 4;
    _ = &start; // Здесь мы берем адрес переменной start, чтобы компилятор не ругался что переменная не изменяется
    _ = &end; // Здесь мы берем адрес переменной end, чтобы компилятор не ругался что переменная не изменяется

    const slice2 = array[start..end];
    std.debug.print("Slice2 type: {}\n", .{@TypeOf(slice2)});
}
```

В результате мы получим вывод:

```
Slice1 type: []i32
Slice2 type: []i32
```

Еще один из вариантов определения среза, это использование рассмотренных ранее аллокаторов. Это полезно, когда размер среза неизвестен на этапе компиляции:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Создание среза с выделением памяти
    const dynamic_slice = try allocator.alloc(i32, 5);
    defer allocator.free(dynamic_slice);

    // Заполнение среза
    for (dynamic_slice, 0..) |*item, i| {
        item.* = @intCast(i + 1);
    }

    // Вывод среза
    for (dynamic_slice) |item| {
        std.debug.print("{} ", .{item});
    }
    std.debug.print("\n", .{});
}
```

Этот код выведет:

```
1 2 3 4 5
```

Для создания среза Вам не обязательно использовать маcсив, Вы можете создавать срез из других срезов:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание среза элементов со 2-го по 4-й (индексы 1-3). Мы явно указываем тип среза
    const slice1: []i32 = array[1..4];

    std.debug.print("Slice type: {}, len: {}\n", .{ @TypeOf(slice1), slice1.len });

    const slice2: []i32 = slice1[1..3];
    std.debug.print("Slice type: {}, len: {}\n", .{ @TypeOf(slice2), slice2.len });
}
```

Этот код выведет:

```
Slice type: []i32, len: 3
Slice type: []i32, len: 2
```

В этом случае оба среза указаывают на один и тот же массив, поэтому изменения в одном срезе будут отражаться в другом. Работая со срезами Вы всегда можете получить текущую длину среза через `slice.len`.

### Доступ к элементам среза

Доступ к элементам среза осуществляется так же, как и к элементам массива — с помощью оператора индексации []. При этом, так как в состав типа среза включена его длина, компилятор при обращении к элементам среза проверит, нет ли выхода за его пределы.

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };
    var slice: []i32 = array[0..];

    // Доступ к элементу по индексу
    const third_element = slice[2];
    std.debug.print("Третий элемент: {}\n", .{third_element});

    // Изменение элемента по индексу
    slice[0] = 10;
    std.debug.print("Обновленный первый элемент: {}\n", .{slice[0]});

    slice[10] = 100; // Тут будет ошибка выхода за пределы среза
}
```

Этот код не скомпилируется из-за последней строчки, но если мы ее уберем, то получим следующий вывод:

```
Третий элемент: 3
Обновленный первый элемент: 10
```

### Модификация срезов

Важно понимать, что срезы — это "проекция" на существующие данные. Когда вы модифицируете элемент среза, вы фактически изменяете соответствующий элемент в базовом массиве или области памяти:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создаем два среза на один и тот же массив
    var slice1: []i32 = array[0..3];
    var slice2: []i32 = array[2..5];

    // Изменяем общий элемент через первый срез
    slice1[2] = 30;

    // Проверяем, что изменение отразилось и во втором срезе
    std.debug.print("slice2[0] = {}\n", .{slice2[0]});
    // Вывод: slice2[0] = 30

    // Проверяем, что изменение отразилось в исходном массиве
    std.debug.print("array[2] = {}\n", .{array[2]});
    // Вывод: array[2] = 30
}
```

Помимо изменения отдельных элементов, срезы можно объединять с помощью аллокаторов. Для этого необходимо выделить новую область памяти, достаточную для хранения данных из обоих срезов, а затем скопировать в неё их содержимое.

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var slice1 = [_]i32{ 1, 2, 3 };
    var slice2 = [_]i32{ 4, 5, 6 };

    // Создаем новый срез, который вместит оба среза
    var result = try allocator.alloc(i32, slice1.len + slice2.len);
    defer allocator.free(result);

    // Копируем данные из первого среза
    std.mem.copy(i32, result[0..slice1.len], &slice1);

    // Копируем данные из второго среза
    std.mem.copy(i32, result[slice1.len..], &slice2);

    // Выводим результат
    for (result) |item| {
        std.debug.print("{} ", .{item});
    }
    std.debug.print("\n", .{});
    // Вывод: 1 2 3 4 5 6
}
```

Иногда чтобы изменить элемент Вам необходимо его найти в срезе. Для этого можно использовать функции стандартной библиотеки в Zig:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };
    var slice = &array;

    // Поиск первого вхождения элемента 3
    const index = std.mem.indexOf(i32, slice, &[_]i32{3});

    if (index) |i| {
        std.debug.print("Элемент 3 найден на позиции {}\n", .{i});
    } else {
        std.debug.print("Элемент 3 не найден\n", .{});
    }
}
```

### Sentinel срезы
Как и массивы в Zig, срезы могут быть sentinel-срезами. Sentinel-срез - это срез, который завершается нулевым значением. Это позволяет использовать срезы в функциях, которые ожидают, что срез будет завершен нулевым значением. Это особенно полезно для совместимости с C-строками, которые заканчиваются нулевым байтом:

```zig
const std = @import("std");

pub fn main() void {
    // Создаем сентинельный срез, заканчивающийся нулем
    var sentinel_array = [_]u8{ 'h', 'e', 'l', 'l', 'o', 0 };
    var sentinel_slice: [:0]u8 = sentinel_array[0..5 :0];

    // В sentinel_slice автоматически добавляется сентинель '0' после 'o'
    std.debug.print("Длина среза: {}\n", .{sentinel_slice.len});
    // Вывод: Длина среза: 5

    // Доступ к сентинелю
    const sentinel = sentinel_slice[sentinel_slice.len];
    std.debug.print("Sentinel: {}\n", .{sentinel});
    // Вывод: Sentinel: 0
}
```

Тип sentinel среза обозначается как `[:sentinel]T`, где `sentinel` — это значение-маркер.

## Строки
В языке программирования Zig строки не являются примитивным типом, а скорее концепцией, построенной на более фундаментальных элементах. Этот подход обеспечивает как силу, так и гибкость, но требует более глубокого понимания для освоения. Zig строки представлены как срезы константных беззнаковых 8-битных целых чисел (`[]const u8`). Это означает, что все рассмотренные выше операции со срезами применимы и к строкам.

Однако есть некоторые особенности и дополнительные функции для работы с текстовыми данными. По умолчанию строки в Zig должна содержать данные в кодировке UTF-8, но как Вы возможно догадались в срезе из `u8` элементов может содержаться все что угодно, а не только символы UTF-8, поэтому работа со строками в Zig вероятно не такая удобная как в Go или Rust. Давайте рассмотрим некоторые примеры работы со строками в Zig.

Для того чтобы создать строку мы естественно не создаем никакой массив или срез, а просто используем литералы строк. Например:

```zig
const std = @import("std");

pub fn main() void {
    const greeting = "Hello, World!";

    std.debug.print("Sting type in zig: {}\n", .{@TypeOf(greeting)});
}
```

Мы получим вывод:

```
$ zig build run
Sting type in zig: *const [13:0]u8
```

Строки созданные с помощью строковых литералов в Zig -  это sentinel строки с маркером `0` и типом данных `[]const u8`. Это сделанно для более удобной совместимости с языком C. Хотя конечно можно создавать строки из массивов символов:

```zig
const char_array = [_]u8{ 'H', 'e', 'l', 'l', 'o' };
const hello_string: []const u8 = &char_array;
```

В Zig, как и во многих других языках программирования, вы можете использовать управляющие последовательности (escape-sequences) для представления специальных символов в строках. Эти последовательности начинаются с обратного слэша (\) и позволяют вставлять символы, которые невозможно напрямую написать в строке, такие как символы новой строки, табуляции и другие.

Вот наиболее часто используемые управляющие последовательности в Zig:
* \n — символ новой строки (newline).
* \t — символ табуляции (tab).
* \\ — обратный слэш (backslash).
* \" — двойная кавычка (double quote).
* \' — одинарная кавычка (single quote).
* \r — возврат каретки (carriage return).
* \0 — нулевой символ (null character).

Символ \n используется для перехода на новую строку. Это полезно, например, при выводе текста с разделением на строки:

```zig
const std = @import("std");

pub fn main() void {
    std.debug.print("Первая строка\nВторая строка\nТретья строка\n", .{});
}
```

В Zig многострочные строки можно создавать с помощью управляющих последовательностей \n. Однако, если строка слишком длинная, её можно разбить на несколько строк с использованием конкатенации:

```zig
const std = @import("std");

pub fn main() void {
    const message =
        "Это длинная строка, " ++
        "разделенная на несколько " ++
        "строк для удобства чтения.\n";
    std.debug.print("{s}", .{message});
}
```

Вывод:

```
Это длинная строка, разделенная на несколько строк для удобства чтения.
```

В Zig также поддерживаются сырые строки (raw strings), которые игнорируют управляющие последовательности. Они полезны, когда нужно вставить текст без обработки специальных символов. Сырые строки обозначаются с помощью \\:

```zig
const std = @import("std");

pub fn main() void {
    const raw_string = \\Это сырая строка. \n и \t не будут обработаны.;
    std.debug.print("{s}\n", .{raw_string});
}
```

Вывод:

```
Это сырая строка. \n и \t не будут обработаны.
```

Важно отметить, что по умолчанию Zig рассматривает строки как последовательности байтов, а не символов Unicode. Для работы с Unicode вам может понадобиться использовать специализированные библиотеки или функции стандартной библиотеки, которые могут интерпретировать UTF-8, UTF-16 или другие кодировки.

Базовая работа с UTF-8 строками может выглядеть так:

```zig
const std = @import("std");

pub fn main() !void {
    // UTF-8 строка с не-ASCII символами
    const utf8_string = "Привет, мир! 🌍";

    // Получаем итератор по UTF-8 кодовым точкам
    var utf8_iter = std.unicode.Utf8Iterator{
        .bytes = utf8_string,
        .i = 0,
    };

    // Итерируемся по кодовым точкам
    while (utf8_iter.nextCodepoint()) |codepoint| {
        // Выводим кодовую точку Unicode и её десятичное значение
        try std.io.getStdOut().writer().print("U+{X:0>4} ({d})\n", .{codepoint, codepoint});
    }
}
```

В данном примере мы используем стандартную библиотеку Zig для работы с UTF-8 строками. Мы создаем UTF-8 строку с не-ASCII символами и получаем итератор по UTF-8 кодовым точкам. Затем мы итерируемся по кодовым точкам и выводим их Unicode и десятичное значение. Это конечно не так удобно как работа с рунами в языке Go, но тем не менее не заставляет Вас самому обрабатывать части UTF-8 символа.

Кроме стандартных строк Вам возможно прийдется тесно работать со строками в стиле языка C, так как Zig тесно интегрируется с кодом на C. Для того чтобы работать с такими строками Вам надо использовать sentinel срезы, которые мы рассматривали ранее:

```zig
const std = @import("std");

pub fn main() void {
    // Обычная строка
    const zig_string = "Hello";

    // Получаем C-строку (нуль-терминированную)
    const c_string: [*:0]const u8 = zig_string.ptr;

    // Для демонстрации вызываем C-функцию, принимающую C-строку
    const length = strlen(c_string);
    std.debug.print("Длина строки: {}\n", .{length});
}

// Объявление внешней C-функции
extern fn strlen(s: [*:0]const u8) usize;
```

Так как строки это обычные срезы, то мы можем обьединять строки используя аллокаторы:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const str1 = "Hello, ";
    const str2 = "World!";

    // Выделяем память для результирующей строки
    var result = try allocator.alloc(u8, str1.len + str2.len);
    defer allocator.free(result);

    // Копируем обе строки в результат
    std.mem.copy(u8, result[0..str1.len], str1);
    std.mem.copy(u8, result[str1.len..], str2);

    std.debug.print("{s}\n", .{result});
    // Вывод: Hello, World!
}
```

В стандартной библиотеке Zig также есть более удобные функции для работы со строками, включая `std.fmt.allocPrint` которая позводит обьеденить строки более простым способом:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const name = "World";
    const greeting = try std.fmt.allocPrint(allocator, "Hello, {s}!", .{name});
    defer allocator.free(greeting);

    std.debug.print("{s}\n", .{greeting});
    // Вывод: Hello, World!
}
```

### Сравнение и поиск строк
Для того чтобы сравнить строки в Zig мы не можем просто сравнить два массива. Для сравнения строк нам необходимо использовать функцию `std.mem.eql` которая сравнивает два массива байтов и возвращает `bool`:

```zig
const std = @import("std");

pub fn main() void {
    const str1 = "hello";
    const str2 = "hello";
    const str3 = "world";

    const are_equal1 = std.mem.eql(u8, str1, str2);
    const are_equal2 = std.mem.eql(u8, str1, str3);

    std.debug.print("str1 == str2: {}\n", .{are_equal1});
    // Вывод: str1 == str2: true

    std.debug.print("str1 == str3: {}\n", .{are_equal2});
    // Вывод: str1 == str3: false
}
```

Для поиска подстроки в строке нам необходимо использовать функцию `std.mem.indexOf` которая возвращает индекс первого вхождения подстроки в строке или `null` если подстрока не найдена:

```zig
const std = @import("std");

pub fn main() void {
    const text = "Hello, World!";
    const substring = "World";

    const index = std.mem.indexOf(u8, text, substring);

    if (index) |i| {
        std.debug.print("Подстрока '{s}' найдена на позиции {}\n", .{substring, i});
    } else {
        std.debug.print("Подстрока '{s}' не найдена\n", .{substring});
    }
    // Вывод: Подстрока 'World' найдена на позиции 7
}
```

## Заключение
Срезы и строки в Zig являются мощными и гибкими инструментами, позволяющими эффективно работать с последовательностями данных и текстом. Понимание их особенностей и возможностей критически важно для написания эффективного и безопасного кода.

Ключевые моменты, которые следует запомнить:

1. Срезы представляют собой "вид" на последовательность элементов и содержат указатель на начало и длину.
2. Строки в Zig — это просто срезы константных байтов (`[]const u8`).
3. Для большинства операций со строками и срезами требуется аллокатор для управления памятью.
4. Zig предлагает sentinel срезы для совместимости с C-строками и другими API, требующими терминаторы.
5. Стандартная библиотека Zig предоставляет множество полезных функций для работы со строками и срезами.
