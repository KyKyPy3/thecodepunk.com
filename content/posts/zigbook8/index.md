---
title: Слайсы и строки
date: 2025-02-28 15:00:00
showTableOfContents: true
showComments: true
katex: true
tags:
  - zig
  - zigbook
---
Слайсы в Zig представляют собой структуру данных, которая содержит указатель на начало последовательности элементов и длину этой последовательности. Их можно рассматривать как "вид" на подмножество массива или области памяти. Эта концепция будет знакома разработчикам, имеющим опыт работы с языками Rust или Go.

## Объявление и создание слайсов

Тип слайса в Zig обозначается как `[]T`, где `T` — это тип элементов. Например, `[]u8` представляет слайс беззнаковых 8-битных целых чисел, а `[]const u8` — слайс, элементы которого не могут быть изменены (что часто используется для строк).

Если Вы попробуете создать слайс из массива или из части массива, но при этом границы вашего слайса будут известны на этапе компиляции, то на самом деле вы создадите не слайс, а просто указатель на массив. Давайте рассмотрим эти два сценария:

```zig
const std = @import("std");

pub fn main() void {
    // Исходный массив
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание слайса всего массива
    const slice1 = &array;

    std.debug.print("Slice1 type: {}\n", .{@TypeOf(slice1)});

    const slice2 = array[1..3];

    std.debug.print("Slice2 type: {}\n", .{@TypeOf(slice2)});
}
```

Этот код выведет следующее:

```
Slice1 type: *[5]i32
Slice2 type: *[2]i32
```

Для того, чтобы явно определить слайс, нам необходимо указать тип создаваемой переменной как тип слайса, например:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создание слайса элементов со 2-го по 4-й (индексы 1-3)
    const slice: []i32 = array[1..4];

    std.debug.print("Slice type: {}\n", .{@TypeOf(slice)});
}
```

В результате мы получим вывод:

```
Slice type: []i32
```

Еще один из вариантов определения слайса, это использование рассмотренных ранее аллокаторов:

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Создание слайса с выделением памяти
    var dynamic_slice = try allocator.alloc(i32, 5);
    defer allocator.free(dynamic_slice);

    // Заполнение слайса
    for (dynamic_slice, 0..) |*item, i| {
        item.* = @intCast(i + 1);
    }

    // Вывод слайса
    for (dynamic_slice) |item| {
        std.debug.print("{} ", .{item});
    }
    std.debug.print("\n", .{});
}
```

### Доступ к элементам слайса

Доступ к элементам слайса осуществляется так же, как и к элементам массива — с помощью оператора индексации `[]`:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };
    var slice: []i32 = array[0..];

    // Доступ к элементу по индексу
    const third_element = slice[2];
    std.debug.print("Третий элемент: {}\n", .{third_element});

    // Изменение элемента по индексу
    slice[0] = 10;
    std.debug.print("Обновленный первый элемент: {}\n", .{slice[0]});
}
```

### Модификация слайсов

Важно понимать, что слайсы — это "проекция" на существующие данные. Когда вы модифицируете элемент слайса, вы фактически изменяете соответствующий элемент в базовом массиве или области памяти:

```zig
const std = @import("std");

pub fn main() void {
    var array = [_]i32{ 1, 2, 3, 4, 5 };

    // Создаем два слайса на один и тот же массив
    var slice1: []i32 = array[0..3];
    var slice2: []i32 = array[2..5];

    // Изменяем общий элемент через первый слайс
    slice1[2] = 30;

    // Проверяем, что изменение отразилось и во втором слайсе
    std.debug.print("slice2[0] = {}\n", .{slice2[0]});
    // Вывод: slice2[0] = 30

    // Проверяем, что изменение отразилось в исходном массиве
    std.debug.print("array[2] = {}\n", .{array[2]});
    // Вывод: array[2] = 30
}
```
